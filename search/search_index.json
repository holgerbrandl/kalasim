{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Welcome to <code>kalasim</code>","text":"<p><code>kalasim</code> is a discrete event simulation framework providing a statically typed API, dependency injection, enterprise-grade persistence, structured logging, and comprehensive automation capabilities for building digital twins.</p> <p><code>kalasim</code> is designed for simulation practitioners, process analysts, and industrial engineers who require advanced modeling capabilities beyond conventional simulation tools to analyze and optimize business-critical systems and processes.</p> <p>Unlike many simulation tools, <code>kalasim</code> is neither low-code nor no-code. It follows a code-first philosophy, enabling version control, scalability, refactoring, continuous integration and deployment (CI/CD), comprehensive unit testing, and modern software engineering practices that ensure robust simulation development.</p> <p><code>kalasim</code> is implemented in Kotlin, leveraging suspendable coroutines for intuitive process definitions. The framework operates on the JVM to deliver enterprise-level performance and scalability, utilizes koin for dependency injection, and integrates Apache Commons Math for statistical analysis and probability distributions. For additional technical references, see acknowledgements. <code>kalasim</code> maintains visualization framework independence while providing integration examples for plotly.kt, lets-plot, and kravis.</p>"},{"location":"#2026-advancing-digital-twin-development","title":"2026 - Advancing Digital Twin Development","text":"<p>Building on our deep understanding of the challenges faced by simulation practitioners, we are pleased to announce significant enhancements to <code>kalasim</code> in 2026, further strengthening its capabilities for enterprise digital twin development.</p> <ul> <li>Enhanced Performance: Significant improvements in simulation performance through optimized event processing and   memory management architectures, enabling accurate modeling of larger, more complex industrial systems</li> <li>Modern Technology Stack: Full compatibility with Kotlin 2.2, providing access to advanced language features and   state-of-the-art development tooling for professional simulation engineering</li> <li>Industry-Validated: <code>kalasim</code> has been successfully deployed across diverse industrial sectors\u2014from automotive   supply chain optimization to precision execution control in semiconductor manufacturing\u2014demonstrating proven   reliability in production-critical environments</li> <li>Expanding Professional Community: A growing network of researchers, practitioners, and industrial engineers   actively contributing to the framework through comprehensive documentation, peer-reviewed case studies, and   collaborative knowledge exchange</li> </ul> <p>KotlinConf Presentation</p> <p>We presented at KotlinConf in Amsterdam, joining technology leaders from cloud computing, mobile development, and data science for collaborative knowledge exchange. Our presentation on \"Make more money by modeling and optimizing your business processes with Kotlin\" was well-received by the professional community:</p>"},{"location":"#core-features","title":"Core Features","text":"<p><code>kalasim</code> is a comprehensive process-oriented discrete event simulation (DES) engine designed for industrial applications.</p> <ul> <li>Simulation entities employ generative process descriptions that define interactions and dependencies   with other system entities</li> <li>A well-defined, expressive process interaction vocabulary,   including hold, request, wait,   and passivate operations</li> <li>An event trigger queue that maintains scheduled future actions and serves as the primary   mechanism for simulation state progression</li> <li>Integrated monitoring and statistical analysis capabilities throughout the entire API</li> </ul> <p>Find out more about the basics of a <code>kalasim</code> simulation.</p>"},{"location":"#first-example","title":"First Example","text":"<p>Let\u2019s start with a very simple model. The example demonstrates the main mode of operation, the core API and the component process model implemented in <code>kalasim</code>. We want to build a simulation where a single car is driving around for a some time before stopping in front of a red traffic light.</p> <pre><code>////Cars.kts\nimport org.kalasim.*\nimport kotlin.time.Duration.Companion.hours\nimport kotlin.time.Duration.Companion.minutes\n\n\nclass Driver : Resource()\nclass TrafficLight : State&lt;String&gt;(\"red\")\n\nclass Car : Component() {\n\n    val trafficLight = get&lt;TrafficLight&gt;()\n    val driver = get&lt;Driver&gt;()\n\n    override fun process() = sequence {\n        request(driver) {\n            hold(30.minutes, description = \"driving\")\n\n            wait(trafficLight, \"green\")\n        }\n    }\n}\n\ncreateSimulation {\n    enableComponentLogger()\n\n    dependency { TrafficLight() }\n    dependency { Driver() }\n\n    Car()\n}.run(5.hours)\n</code></pre> <p>Curious about an in-depth analysis of this example? It's your lucky day, see here.</p>"},{"location":"#how-to-contribute","title":"How to Contribute","text":"<p>We welcome contributions from the community. Please submit ideas and suggestions to the project issue tracker.</p> <p>Pull requests are always appreciated and will be reviewed promptly.</p>"},{"location":"#support","title":"Support","text":"<p>For questions and discussions, please visit the project's discussion forum.</p> <p>You are also invited to join our community on kotlinlang.slack.com in the <code>#kalasim</code> channel.</p>"},{"location":"about/","title":"About","text":""},{"location":"about/#license","title":"License","text":"<p><code>kalasim</code> is licensed under MIT License.</p>"},{"location":"about/#acknowledgements","title":"Acknowledgements","text":""},{"location":"about/#salabim","title":"salabim","text":"<p><code>kalasim</code> started off as a blunt rewrite of salabim. We are deeply thankful for its permissive licence that enabled setting up <code>kalasim</code>. A great starting point was in particular the wonderful article salabim: discrete event simulation and animation in Python.</p> <p><code>salabim</code>s excellent documentation and wonderful examples made this project possible after all. <code>kalasim</code> reimplements all core APIs of <code>salabim</code> in a more typesafe API while also providing better test coverage, real-time capabilities and (arguably) more modern built-in support for visualization.</p> <ul> <li>Salabim, Discrete Event Simulation In Python - PyCon 2018 Talk</li> <li>Python.init Podcast: Salabim - Great podcast episode with Ruud van der Ham</li> </ul>"},{"location":"about/#simmer","title":"simmer","text":"<p>simmer is a process-oriented and trajectory-based Discrete-Event Simulation (DES) package for R.</p> <p>It centres around the concept of a trajectory that defines a component lifecycle. To enable scale it is built on top of Rcpp (C++ backend for R).</p> <ul> <li>Great overview simmer: Discrete-Event Simulation for R, Ucar et al., 2019</li> <li>Support for optimization in simmer.optim</li> </ul> <p>We have adopted several examples and documentation bits from <code>simmer</code>, and are deeply grateful to the simmer developers for providing such a great and well maintained tool. <code>simmer</code> has also been a great source of inspiration to implement in particular the monitoring and visualization API of <code>kalasim</code>.</p>"},{"location":"about/#simjulia","title":"SimJulia","text":"<p>SimJulia is a combined continuous time / discrete event process oriented simulation framework written in Julia inspired by the Simula library DISCO and the Python library SimPy.</p> <p>We have adopted several examples and documentation bits from <code>SimJulia</code>, and are deeply grateful its developers for providing such a great and well maintained tool.</p>"},{"location":"about/#simpy","title":"SimPy","text":"<p>SimPy is a process-based discrete-event simulation framework based on standard Python. Processes in <code>SimPy</code> are defined by Python generator functions. <code>SimPy</code> also provides various types of shared resources to model limited capacity congestion points (like servers, checkout counters and tunnels).</p> <p>We have adopted several examples and documentation bits from <code>SimPy</code>, and are deeply grateful its developers for providing such a great and well maintained tool.</p>"},{"location":"about/#dsol","title":"DSOL","text":"<p>DSOL3 which is an open source, Java based suite of Java classes for continuous and discrete event simulation</p> <ul> <li>The wonderful DSOL manual</li> <li>The DSOL simulation suite - Enabling multi-formalism simulation in a distributed context, PhD Thesis, Peter Jacobs, 2005</li> <li>Mastering D-SOL: A Java based suite for simulation with several examples, 2006</li> <li>opentrafficsim is a traffic simulation built with DSOL3</li> </ul>"},{"location":"about/#libraries-used-to-build-kalasim","title":"Libraries used to build kalasim","text":"<p><code>kalasim</code>  is built on top of some great libraries. It was derived as merger of ideas, implementation and documentation from the following projects:</p> <ul> <li>Kotlin - Not really a library, but for obvious reasons the foundation of this project</li> <li>koin which is a pragmatic lightweight dependency injection framework for Kotlin developers</li> <li>Apache Commons Math is a library of lightweight, self-contained mathematics and statistics components</li> <li>jsonbuilder is a small artifact that serves a single purpose: It allows creating json using an idiomatic kotlin DSL. Its main purpose it to make sure <code>kalasim</code> provides a machine-readable log-format for all basics in a simulation.</li> <li>kotest.io is a flexible and elegant multiplatform test framework, assertions library, and property test library for Kotlin. We use it to make sure kalasim fulfils its component contract.</li> </ul> <p>Visualization</p> <ul> <li>https://github.com/holgerbrandl/kravis which implements a grammar to create a wide range of plots using a standardized set of verbs</li> <li>https://github.com/JetBrains/lets-plot-kotlin is an open-source plotting library for statistical data.</li> </ul> <p>Inspirations</p> <ul> <li>atomic-agents - Spatial Agent-based Modeling in JavaScript</li> </ul>"},{"location":"about/#youkit-profiler","title":"YouKit Profiler","text":"<p>With <code>kalasim</code>, we strive to enable large-scale time-discrete simulation models. To optimize the API and the engine for perormance, we rely on YourKit profiler. With its wonderful interface into JDK performace metrics, YourKit profiler allows us to signifantly improve the overall speed while reducing the memory footprint of <code>kalasim</code>.</p> <p></p> <p>YourKit supports open source projects with innovative and intelligent tools for monitoring and profiling Java and .NET applications. YourKit is the creator of YourKit Java Profiler.</p>"},{"location":"about/#repo-maintainer","title":"Repo Maintainer","text":"<p>Dr. Holger Brandl is a seasoned solution architect and project/team lead with deep experience in automation and material-flow optimization across manufacturing environments. Over the past 6+ years, he has designed and implemented data-driven solutions that improve WIP flow, transparency, and operational efficiency\u2014bridging software architecture, production processes, and applied AI/predictive analytics.</p> <p>His industry focus includes semiconductor and electronics manufacturing as well as automotive, with expertise spanning material-flow simulation, scheduling and sequencing, predictive maintenance/quality, and manufacturing analytics. He has led cross-functional teams from concept to rollout, contributed to product design of AI-driven planning solutions, and supported pre-sales and portfolio activities. Holger is also a published author (including journals such as Science, Nature, and Cell).</p> <p>To stay in sync with what's happening in tech, he develops open-source tools, methods and algorithms for bioinformatics, high-performance computing and data science. He is passionate about machine learning, AI, analytics, elegant APIs and data visualization. His professional scope mainly centers around systems biology and industrial manufacturing.</p>"},{"location":"advanced/","title":"Advanced","text":""},{"location":"advanced/#clock-synchronization","title":"Clock Synchronization","text":"<p>In simulation a clear distinction is made between real time and simulation time. With real time we refer to the wall-clock time. It represents the execution time of the experiment. The simulation time is an attribute of the simulator.</p> <p>To support use cases where a simulation may drive a demonstration or system check, the <code>kalasim</code> API allows to run a simulation at a defined clock speed. Such real-time simulations may be necessary</p> <ul> <li>If you have hardware-in-the-loop</li> <li>If the intent of the simulation is to drive a visualization of a process</li> <li>If there is human interaction with your simulation, or</li> <li>If you want to analyze the real-time behavior of an algorithm</li> </ul> <p><pre><code>import org.kalasim.*\nimport kotlin.time.Duration.Companion.seconds\n\nval timeBefore = System.currentTimeMillis()\n\ncreateSimulation {\n    enableComponentLogger()\n\n    // enable real-time clock synchronization\n    ClockSync(tickDuration = 1.seconds)\n\n    run(10)\n}\n\nprintln(\"time passed ${System.currentTimeMillis() - timeBefore})\")\n</code></pre> This example will execute in 10 seconds. Since the simulation is empty (for educational reasons to keep the focus on the clock here), it is entirely idle during that time.</p> <p>To enable clock synchronization, we need to add a <code>ClockSync</code> to our simulation. We need to define what one tick in simulation time corresponds to in wall time. In the example, one tick equals to one second wall time. This is configured with the parameter <code>tickDuration</code>. It defines the duration of a simulation tick in wall clock coordinates. It can be created with <code>Duration.ofSeconds(1)</code>, <code>Duration.ofMinutes(10)</code> and so on.</p> <p><code>ClockSync</code> also provides settings for more advanced uses-cases</p> <ul> <li>To run simulations, in more than realtime, the user can specify <code>speedUp</code> to run a simulation faster (<code>speedUp</code> &gt; 1) or slower (<code>speedUp</code> &lt; 1) than realtime. It defaults to <code>1</code>, that is no speed-up will be applied.</li> <li>The argument <code>syncsPerTick</code> defines how often a clock synchronization should happen. Per default it synchronizes once per tick (i.e. an 1-increment of simulation time).</li> </ul> <p>It may happen that a simulation is too complex to run at a defined clock. In such a situation, it (i.e. <code>Environment.run()</code>) will throw a <code>ClockOverloadException</code> if the user has specified a maximum delay <code>maxDelay</code> parameter between simulation and wall clock coordinates.</p>"},{"location":"advanced/#operational-control","title":"Operational Control","text":"<p>Even if <code>kalasim</code> tries to provide a simplistic, efficient, declarative approach to define a simulation, it may come along with computational demands simulation. To allow introspection into time-complexity of the underlying computations, the user may want to enable the built-in <code>env.tickMetrics</code> monitor to analyze how much time is spent per time unit (aka tick). This monitor can be enabled by calling <code>enableTickMetrics()</code> when configuring the simulation.</p> <pre><code>import org.kalasim.*\nimport org.kalasim.plot.letsplot.display\n\ncreateSimulation {\n    enableTickMetrics()\n\n    object : Component() {\n        override fun process() = sequence {\n            while(true) {\n                // create some artificial non-linear compute load\n                if(nowTT.value &lt; 7)\n                    Thread.sleep((nowTT.value * 100).toLong())\n                else {\n                    Thread.sleep(100)\n                }\n\n                hold(1.minutes)\n            }\n        }\n    }\n\n    run(10.hours)\n\n    tickMetrics.display().show()\n}\n</code></pre>"},{"location":"advanced/#performance-tuning","title":"Performance tuning","text":"<p>There are multiple ways to improve the performance of a simulation. </p> <ol> <li>Disable internal event logging: The interaction model is configured by default to provide insights into the simulation via the event log. However, to optimize performance of a simulation a user may want to consume only custom event-types. If so, internal interaction logging can be adjusted by setting a logging policy.  </li> <li>Disable component statistics: Components and queues log various component statistics with built-in monitors which can be adjusted by setting a logging policy to reduce compute and memory footprint of a simulation.  </li> <li>Set the correct <code>AssertMode</code>: The assertion mode determines which internal consistency checks are being performed.  The mode can be set to <code>Full</code> (Slowest), <code>Light</code> (default) or <code>Off</code> (Fastest). Depending on simulation logic and complexity, this will improve performance by ~20%.</li> </ol> <p>To further fine-tune and optimize simulation performance and to reveal bottlenecks, a JVM profiler (such as yourkit or the built-in profiler of Intellij IDEA Ultimate) can be used. Both call-counts and spent-time analysis have been proven useful here. </p>"},{"location":"advanced/#continuous-simulation","title":"Continuous Simulation","text":"<p>For some use-cases, simulations may run for a very long simulation and wall time. To prevent internal metrics gathering from consuming all available memory, it needs to be disabled or at least configured carefully. This can be achieved, but either disabling timelines and monitors manually on a per-entity basis, or by setting a sensible default policy via <code>Environment.entityTrackingDefaults</code></p> <p>For each entity type a corresponding tracking-policy <code>TrackingConfig</code> can be provisioned along with an entity matcher to narrow down its scope. A tracking-policy allows to change </p> <ol> <li>How events are logged </li> <li>How internal metrics are gathered</li> </ol> <p>There are different default implementations, but the user can also implement and register custom tracking-configurations.</p> <ul> <li>ComponentTrackingConfig</li> <li>ResourceTrackingConfig</li> <li>StateTrackingConfig</li> <li>ComponentCollectionTrackingConfig</li> </ul> <pre><code>//import org.kalasim.*\nimport org.kalasim.misc.*\nimport kotlin.time.Duration.Companion.hours\nimport kotlin.time.Duration.Companion.minutes\n\n\nclass Driver : Resource(trackingConfig = ResourceTrackingConfig(trackUtilization = false))\nclass TrafficLight : State&lt;String&gt;(\"red\", trackingConfig = StateTrackingConfig(logCreation = false))\n\nclass Car : Component(\n    trackingConfig = ComponentTrackingConfig(logInteractionEvents = false)\n) {\n\n    val trafficLight = get&lt;TrafficLight&gt;()\n    val driver = get&lt;Driver&gt;()\n\n    override fun process() = sequence {\n        request(driver) {\n            hold(30.minutes, description = \"driving\")\n\n            wait(trafficLight, \"green\")\n        }\n    }\n}\n\ncreateSimulation {\n    enableComponentLogger()\n\n    // in addition or alternatively we can also change the environment defaults\n    entityTrackingDefaults.DefaultComponentConfig =\n        ComponentTrackingConfig(logStateChangeEvents = false)\n\n    // create simulation entities\n    dependency { TrafficLight() }\n    dependency { Driver() }\n\n    Car()\n}.run(5.hours)\n</code></pre> <p>Note</p> <p>Tracking configuration policies defaults must be set before instantiating simulation entities to be used</p> <p>To disable all metrics and to minimize internal event logging, the user can run <code>env.entityTrackingDefaults.disableAll()</code></p> <p>The same mechanism applies also fine-tune the internal event logging. By disabling some -  not-needed for production - events, simulation performance can be improved significantly.</p>"},{"location":"advanced/#save-and-load-simulations","title":"Save and Load Simulations","text":"<p><code>kalasim</code> does not include a default mechanism to serialize and deserialize simulations yet. However, it seems that with xstream that <code>Environment</code> can be saved including its current simulation state across all included entities. It can be restored from the xml snapshot and continued with <code>run()</code>.</p> <p>We have not succeeded to do the same with gson yet. Also, some experiments with kotlinx.serialization were not that successful.</p>"},{"location":"advanced/#internal-state-validation","title":"Internal State Validation","text":"<p>The simulation engine provides different levels of internal consistency checks. As these are partially computationally expensive these can be be/disabled. There are 3 modes</p> <ul> <li><code>OFF</code> - Productive mode, where asserts that may impact performance are disabled.</li> <li><code>LIGHT</code> - Disables compute-intensive asserts. This will have a minimal to moderate performance impact on simulations.</li> <li><code>FULL</code> - Full introspection, this will have a measurable performance impact on simulations. E.g. it will validate that passive components are not scheduled, and queued components have unique names.</li> </ul> <p>Switching off asserts, will typically optimize performance by another ~20% (depending on simulation logic).</p>"},{"location":"analysis/","title":"Analysis","text":"<p>A core aspect when building simulations is to understand, define and modulate the inherent system dynamics. To build a correct simulation, the designer/developer must carefully analyze how states progress over time.</p> <p>To facilitate this process, <code>kalasim</code> offers various means to analyze data created by a simulation</p> <ul> <li>The Event Log tracks events in a simulation</li> <li>Monitors track state and statistics of the basic elements within a simulation, and may be used for domain-specific entities as well</li> <li>Lifecycle Records summarize a component's states history</li> <li>visualization to inspect complex spatio-temporal patterns   </li> </ul>"},{"location":"analysis/#monitors","title":"Monitors","text":"<p>See chapter about monitors.</p>"},{"location":"analysis/#event-log","title":"Event Log","text":"<p>See chapter about event logging.</p>"},{"location":"analysis/#visualization","title":"Visualization","text":"<p>See chapter about visualization.</p>"},{"location":"analysis/#component-status","title":"Component Status","text":"<p>The state transition of a component provide value insight into its behavior. This is facilitated by lifecycle statistics <code>ComponentLifecycleRecord</code> that summarize a component's states history. </p> <p>These data can also be transformed easily into a table as well <pre><code>val customers : List&lt;Component&gt; // = ...\nval records: List&lt;ComponentLifecycleRecord&gt; = customers.map { it.toLifeCycleRecord() }\n\nrecords.asDataFrame()\n</code></pre></p> <p>This transforms the <code>customers</code> straight into a <code>krangl</code> dataframe with the following structure</p> <pre><code>A DataFrame: 1034 x 11\n      component   createdAt   inCurrent    inData   inDataSince   inInterrupted   inPassive\n 1    Vehicle.1       0.366           0   989.724        10.276               0           0\n 2    Vehicle.2       1.294           0   984.423        15.577               0           0\n 3    Vehicle.3       1.626           0   989.724        10.276               0           0\n 4    Vehicle.4       2.794           0   989.724        10.276               0           0\nand 1024 more rows, and and 4 more variables: inScheduled, inStandby, inWaiting\n</code></pre> <p>Clearly if needed, the user may also work with the records directly. For instance to configure a visualization.</p>"},{"location":"analysis/#replication","title":"Replication","text":"<p>Running a simulation just once, often does not provide sufficient insights into the dynamics of the system under consideration. Often, the user may want to execute a model many times with altered initial conditions, and then perform a statistical analysis over the output. This is also considered as what-if analyis. See here for simple example.</p> <p>By design <code>kalasim</code> does not make use of parallelism. So when scaling up execution to run in paralell, we need to be careful, that the internal dependency injection (which relates by default to a global context variable) does not cause trouble. See here for an example that defines a parameter grid to be assessed with multi-threading with a simulation run per hyper-parameter.</p>"},{"location":"analysis/#component-tracking","title":"Component Tracking","text":"<p>To prevent memory leaks, the environment just keeps track of scheduled components, that is components that are queued for execution. In some situations the user may want to track all components irrespective of their queuing status. This can be achieved by setting up a component collector before creating the components</p> <pre><code>createSimulation{\n    val cc = componentCollector()\n\n    // create components\n    Component(\"foo\")\n    Component(\"bar\")\n\n    // analyze all components created until this point\n    cc.size // will be 2\n}\n</code></pre>"},{"location":"animation/","title":"Process Animation","text":"<p>Animation is a powerful tool to debug, test and demonstrate simulations.</p> <p>It is possible use shapes (lines, rectangles, circles, etc), texts as well image to visualize the state of a simulation model. Statistical properties may be animated by showing the current value against the time.</p> <p>Process animations can be</p> <ul> <li>Synchronized with the simulation clock and run in real time (synchronized)</li> <li>Advanced per simulation event (non-synchronized)</li> </ul>"},{"location":"animation/#how-to-get-started","title":"How to get started?","text":"<p>All it takes is a single dependency</p> <pre><code>dependencies {\n    api(\"com.github.holgerbrandl:kalasim-animation:0.7.97\")\n}\n</code></pre> <p>The dependency pull everything you need to animate simulations.</p> <p>For fully worked out examples, have a look at the lunar mining or the office tower.</p> <p>If you're not sure how to configure gradle, you could also start with the provided processes animation template project. </p>"},{"location":"animation/#under-the-hood","title":"Under the hood","text":"<p>OPENRNDR is an open source framework for creative coding, written in Kotlin that simplifies writing real-time interactive software.</p> <p> For more details see https://openrndr.org/</p> <p>Process animation with <code>kalasim</code> is using <code>OPENRNDR</code> as backend and rendering engine. Animation is not part of the core API of kalasim, but support is provided by a decorator types (extending their respective base-type)</p> <ul> <li><code>Component</code> -&gt; <code>AnimationComponent</code></li> <li><code>Resource</code> -&gt; <code>AnimationResource</code></li> <li><code>ComponentQueue</code> -&gt; <code>AnimationResource</code></li> </ul> <p>These components are worked out below.</p>"},{"location":"animation/#animation-template","title":"Animation Template","text":"<p>The basic structure of a process animation is as follows</p> <p><pre><code>// package org.kalasim.animation\n\nimport kotlinx.coroutines.*\nimport org.kalasim.ClockSync\nimport org.kalasim.Environment\nimport org.kalasim.misc.DependencyContext\nimport org.openrndr.application\nimport org.openrndr.color.ColorRGBa\nimport org.openrndr.draw.loadFont\nimport org.openrndr.draw.loadImage\nimport java.awt.geom.Point2D\nimport java.lang.Thread.sleep\nimport kotlin.time.Duration.Companion.milliseconds\nimport kotlin.time.DurationUnit\n\nfun main() {\n    application {\n        // setup simulation model\n        val sim = object : Environment(tickDurationUnit = DurationUnit.SECONDS) {\n            init {\n                ClockSync(tickDuration = 10.milliseconds, syncsPerTick = 100)\n            }\n\n            // instantiate components (not fully worked out here)\n            val worker = AnimationComponent(Point2D.Double(1.0, 3.0))\n        }\n\n        // configure the window\n        configure {\n            width = 1024\n            height = 800\n            windowResizable = true\n            title = \"Simulation Name\"\n        }\n\n        var frameCounter = 0\n\n        program {\n            // load resources such as images\n            val image = loadImage(\"src/main/resources/1024px-Phlegra_Montes_on_Mars_ESA211127.jpg\")\n//            val truck = loadSVG(\"src/main/resources/tractor-svgrepo-com.svg\")\n            val font = loadFont(\"file:IBM_Plex_Mono/IBMPlexMono-Bold.ttf\", 24.0)\n\n            // optionally enable video recording\n//            extend(ScreenRecorder())\n\n            extend {\n                // draw background\n                drawer.image(image, 0.0, 0.0, width.toDouble(), height.toDouble())\n\n                // visualize simulation entities\n                with(drawer) {\n                    val workerPosition = sim.worker.currentPosition\n                    circle(workerPosition.x, workerPosition.y, 10.0)\n                }\n\n\n                // draw info &amp; statistics\n                drawer.defaults()\n                drawer.fill = ColorRGBa.WHITE\n                drawer.fontMap = font\n                drawer.text(\"NOW: ${sim.now}\", width - 150.0, height - 30.0)\n                drawer.text(\"Frame: ${frameCounter++}\", width - 150.0, height - 50.0)\n            }\n        }\n\n        // Start simulation model\n        CoroutineScope(Dispatchers.Default).launch {\n            //rewire koin context for dependency injection to async execution context\n            DependencyContext.setKoin(sim.getKoin())\n            // wait because Openrndr needs a second to warm up\n            sleep(3000)\n            sim.run()\n        }\n    }\n}\n</code></pre> Templates including gradle build files) sources can be found in the repo. F</p> <p>For an in-depth walkthrough of the elements the an animation, see https://guide.openrndr.org/ </p>"},{"location":"animation/#animating-components","title":"Animating Components","text":"<p>By changing the base class of a component from <code>Component</code> to <code>org.kalasim.animation.AnimationComponent</code>, we decorate the original with the following features</p> <ul> <li>Instances can have an initial position (modelled as <code>Point2D</code>)</li> <li>With <code>moveTo(newLocation:Point2D)</code> the API provides suspendable wrapper around <code>hold()</code> </li> <li>While being on hold, an animation can always request the current position with <code>c.currentPosition</code>. Positions are linearly interpolated.</li> </ul>"},{"location":"animation/#animating-hold-interactions","title":"Animating <code>hold()</code> Interactions","text":"<p>An animation can track the status  <code>hold()</code> interaction with <code>holdProgress</code>. It's a 2 step process</p> <ol> <li> <p>First, we need to register what type of holds we would like to monitor  <pre><code>val UNLOADING = \"Unloading\"\nval c: Component = Component()\n\nc.registerHoldTracker(UNLOADING) { it.description.startsWith(\"unloading\")}\n</code></pre></p> </li> <li> <p>Once it has been registered, the tracker can be consumed in the rendering loop with  <code>isHolding</code> and <code>holdProgress</code>. <pre><code>if(c.isHolding(UNLOADING)) {\n    drawer.contour(contour.sub(0.0, (1 - c.holdProgress(UNLOADING)!!)))\n}\n</code></pre></p> </li> </ol> <p>For a fully worked out example, see how the mining process is animated in the  lunar mining demo.</p>"},{"location":"animation/#animating-resources","title":"Animating Resources","text":"<p>Dedicated support for resource rendering is coming soon. See lunar mining to see how it's done.  </p>"},{"location":"animation/#animating-states","title":"Animating States","text":"<p>Dedicated support for state rendering is coming soon.</p>"},{"location":"animation/#animating-queues-collections","title":"Animating Queues &amp; Collections","text":"<p>Dedicated support for collection rendering is coming soon.</p>"},{"location":"animation/#other-animation-frontends","title":"Other animation frontends","text":"<p>The animation support API does not bind to a particular rendering engine. However, until now only https://openrndr.org/ has been explored for process animation with <code>kalasim</code>.</p>"},{"location":"basics/","title":"Simulation Basics","text":"<p>The beauty of discrete event simulation is its very limited vocabulary which still allows expressing complex system dynamics. In essence, <code>kalasim</code> relies on just a handful of elements to model real-world processes.</p> <ul> <li>Components</li> <li>Resources</li> <li>States</li> <li>Collections</li> <li>Generators</li> </ul>"},{"location":"basics/#simulation-environment","title":"Simulation Environment","text":"<p>All entities in a simulation are governed by an environment context. Every simulation lives in exactly one such environment. The environment provides means for controlled randomization, dependency injection, and most importantly manages the event queue.</p> <p>The environment context of a kalasim simulation is an instance of  <code>org.kalasim.Environment</code>, which can be created using simple instantiation or via a builder called <code>createSimulation</code></p> <pre><code>val env : Environment = createSimulation(){\n    // enable logging of built-in simulation metrics\n    enableComponentLogger()\n\n    // Create simulation entities in here \n    Car()\n    Resource(\"Car Wash\")\n}.run(5.minutes)\n</code></pre> <p>Within its environment, a simulation contains one or multiple components with process definitions that define their behavior and interplay with other simulation entities.</p> <p>Very often, the user will define custom Environments to streamline simulation API experience.</p> <pre><code>class MySim(val numCustomers: Int = 5) : Environment() {\n    val customers = List(numCustomers) { Customer(it) }\n}\n\nval sim = MySim(10)\nsim.run()\n\n// analyze customers\nsim.customers.first().statusTimeline.display()\n</code></pre> <p>To configure references first, an <code>Environment</code> can also be instantiated by configuring dependencies first with <code>configureEnvironment</code>. Check out the Traffic example to learn how that works.</p>"},{"location":"basics/#running-a-simulation","title":"Running a simulation","text":"<p>In a discrete event simulation a clear distinction is made between real time and simulation time. With real time we refer to the wall-clock time. It represents the execution time of the experiment. The simulation time is an attribute of the simulator.</p> <p>As shown in the example from above a simulation is usually started with <code>sim.run(duration)</code>. The simulation will progress for <code>duration</code> which is an instance of <code>kotlin.time.Duration</code>. By doing so we may stop right in the middle of a process. As shown in the example from above a simulation is usually started with <code>sim.run(duration)</code>. The simulation will progress for <code>duration</code> which is an instance of <code>kotlin.time.Duration</code>. By doing so we may stop right in the middle of a process.</p> <pre><code>sim.run(2.hours)\n\nsim.run(1.4.days) // fractionals are suportes as well\nsim.run(until = now + 3.hours) // simulation-time plus 3 hours\n</code></pre> <p>Alternatively for backward compatbility reasons and to write down examples without any specific time dimension, we can also run for a given number of ticks which is resolved by the <code>tickDuration</code> of the simulation enviroment.</p> <pre><code>sim.run(23) // run for 23 ticks\nsim.run(5) // run for some more ticks\n\nsim.run(until = 42.asTickTime()) // run until internal simulation clock is 42 \n\nsim.run() // run until event queue is empty\n</code></pre> <p>Tip</p> <p>A component can always stop the current simulation by calling <code>stopSimulation()</code> in its process definition. See here for fully worked out example.</p>"},{"location":"basics/#event-queue","title":"Event Queue","text":"<p>The core of kalasim is an event queue ordered by scheduled execution time, that maintains a list of events to be executed. To provide good insert, delete and update performance, <code>kalasim</code> is using a <code>PriorityQueue</code> internally. Components are actively and passively scheduled for reevaluating their state. Technically, event execution refers to the continuation of a component's process definition.</p> Kalasim Execution Model"},{"location":"basics/#execution-order","title":"Execution Order","text":"<p>In the real world, events often appear to happen at the same time. However, in fact events always occur at slightly differing times. Clearly the notion of same depends on the resolution of the used time axis. Birthdays will happen on the same day whereas the precise birth events will always differ in absolute timing.</p> <p>Even if real-world processes may run \"in parallel\", a simulation is processed sequentially and deterministically. With the same random-generator initialization,  you will always get the same simulation results when running your simulation multiple times.</p> <p>Although, <code>kalasim</code> supports double-precision to schedule events, events will inevitably arise that are scheduled for the same time. Because of its  single-threaded, deterministic execution model (like most DES frameworks),  <code>kalasim</code>  processes events sequentially \u2013 one after another. If two events are scheduled at the same time, the one scheduled first will also be the processed first (FIFO).</p> <p>As pointed out in Ucar, 2019, there are many situations where such simultaneous events may occur in simulation. To provide a well-defined behavior in such situations, process interaction methods (namely  <code>wait</code>, <code>request</code>,  <code>activate</code> and <code>reschedule</code>) support user-provided schedule priorities. With the parameter <code>priority</code> in these interaction methods, it is possible to order components scheduled for the same time in the event-queue. Events with higher priority are executed first in situations where multiple events are scheduled for the same simulation time.</p> <p>There are different predefined priorities which correspond the following sort-levels</p> <ul> <li><code>LOWEST</code> (-20)</li> <li><code>LOW</code> (-10)</li> <li><code>NORMAL</code> (0)</li> <li><code>IMPORTANT</code> (10)</li> <li><code>CRITICAL</code> (20)</li> </ul> <p>The user can also create more fine-grained priorities with <code>Priority(23)</code></p> <p>In contrast to other DSE implementations, the user does not need to make sure that a resource <code>release()</code> is prioritized over a simultaneous <code>request()</code>. The engine will automatically reschedule tasks accordingly.</p> <p>So the key points to recall are</p> <ul> <li>Real world events may appear to happen at the same discretized simulation time</li> <li>Simulation events are processed one after another, even if they are scheduled for the same time</li> <li>Race-conditions between events can be avoided by setting a <code>priority</code></li> </ul>"},{"location":"basics/#configuring-a-simulation","title":"Configuring a Simulation","text":"<p>To minimze initial complexity when creating an environment, some options can be enabled within the scope of an environment * <code>enableTickMetrics()</code> - See tick metrics * <code>enableComponentLogger()</code> - Enable the component logger to track component status</p>"},{"location":"basics/#dependency-injection","title":"Dependency Injection","text":"<p>Kalasim is building on top of koin to inject dependencies between elements of a simulation. This allows creating simulation entities such as resources, components or states conveniently without passing around references.</p> <p><pre><code>class Car : Component() {\n\n    val gasStation by inject&lt;GasStation&gt;()\n\n    // we could also distinguish different resources of the same type \n    // using a qualifier\n//    val gasStation2 : GasStation by inject(qualifier = named(\"gs_2\"))\n\n    override fun process() = sequence {\n        request(gasStation) {\n            hold(2, \"refill\")\n        }\n\n        val trafficLight = get&lt;TrafficLight&gt;()\n        wait(trafficLight, \"green\")\n    }\n}\n\ncreateSimulation{\n    dependency { TrafficLight() }\n    dependency { GasStation() }\n\n    // declare another gas station and specify \n    dependency(qualifier = named(FUEL_PUMP)) {}\n\n    Car()\n}\n</code></pre> As shown in the example, the user can simply pull dependencies from the simulation environment using <code>get&lt;T&gt;()</code> or <code>inject&lt;T&gt;()</code>. This is realized with via Koin Context Isolation provided by a thread-local <code>DependencyContext</code>. This  context is a of type <code>DependencyContext</code>. It is automatically created when calling <code>createSimulation</code> or by instantiating a new simulation <code>Environment</code>. This context is kept as a static reference, so the user may omit it when creating simulation entities. Typically, dependency context management is fully transparent to the user.</p> <pre><code>Environment().apply {\n    // implicit context provisioning (recommended)\n    val inUse = State(true)\n\n    // explicit context provisioning\n    val inUse2 = State(true, koin = getKoin())\n}\n</code></pre> <p>In the latter case, the context reference is provided explicitly. This is usually not needed nor recommended.</p> <p>Instead of sub-classing, we can also use qualifiers to refer to dependencies of the same type</p> <pre><code>class Car : Component() {\n\n    val gasStation1 : GasStation by inject(qualifier = named(\"gas_station_1\"))\n    val gasStation2 : GasStation by inject(qualifier = named(\"gas_station_2\"))\n\n    override fun process() = sequence {\n        // pick a random gas-station\n        request(gasStation, gasStation, oneOf = true) {\n            hold(2, \"refill\")\n        }\n    }\n}\n\ncreateSimulation{\n    dependency(qualifier = named(\"gas_station_1\")) { GasStation() }\n    dependency(qualifier = named(\"gas_station_2\")) { GasStation() }\n\n    Car()\n}\n</code></pre>"},{"location":"basics/#threadsafe-registry","title":"Threadsafe Registry","text":"<p>Because of its thread locality awareness, the dependency resolver of <code>kalasim</code> allows for parallel simulations. That means, that even when running multiple simulations in parallel in different threads, the user does not have to provide a dependency context (called <code>koin</code>) argument when creating new simulation entities (such as components). </p> <p>For a simulation example with multiple parallel <code>Environment</code>s see ATM Queue</p>"},{"location":"basics/#simple-types","title":"Simple Types","text":"<p>Koin does not allow injecting simple types. To inject simple variables, consider using a wrapper class. Example</p> <pre><code>////SimpleInject.kts\nimport org.kalasim.*\n\ndata class Counter(var value: Int)\n\nclass Something(val counter: Counter) : Component() {\n\n    override fun process() = sequence&lt;Component&gt; {\n        counter.value++\n    }\n}\ncreateSimulation {\n    dependency { Counter(0) }\n    dependency { Something(get()) }\n\n    run(10)\n}\n</code></pre> <p>For details about how to use lazy injection with <code>inject&lt;T&gt;()</code> and instance retrieval with <code>get&lt;T&gt;()</code> see koin reference.</p> <p>Examples</p> <ul> <li>Traffic</li> <li>Car Wash</li> <li>Gas Station</li> </ul>"},{"location":"basics/#randomness-distributions","title":"Randomness &amp; Distributions","text":"<p>Experimentation in a simulation context relates to large part to controlling randomness. With <code>kalasim</code>, this is achieved by using probabilistic distributions which are internally backed by apache-commons-math. A simulation always allows deterministic execution while still supporting pseudo-random sampling. When creating a new simulation environment, the user can provide a random seed which used internally to initialize a random generator. By default kalasim, is using a fixed seed of <code>42</code>. Setting a seed is in particular useful when running a simulation repetitively (possibly with parallelization).</p> <pre><code>createSimulation(randomSeed = 123){\n    // internally kalasim will create a random generator\n    //val r = Random(randomSeed)\n\n    // this random generator is used automatically when\n    // creating distributions\n    val normDist = normal(2)   \n}\n</code></pre> <p>With this internal random generator <code>r</code>, a wide range of  probability distributions are supported to provide controlled randomization. That is, the outcome of a simulation experiment will be the same if the same seed is being used.  </p> <p>Important</p> <p>All randomization/distribution helpers are accessible  from an <code>Environment</code> or <code>SimulationEntity</code> context only. That's because kalasim needs the context to associate the random generator of the simulation (which is also bound to the current thread).</p> <p>Controlled randomization is a key aspect of every process simulation. Make sure to always strive for reproducibility by not using randomization outside the simulation context.</p>"},{"location":"basics/#continuous-distributions","title":"Continuous Distributions","text":""},{"location":"basics/#numeric-distributions","title":"Numeric Distributions","text":"<p>The following continuous distributions can be used to model randomness in a simulation model</p> <ul> <li><code>uniform(lower = 0, upper = 1)</code></li> <li><code>exponential(mean = 3)</code></li> <li><code>normal(mean = 0, sd = 1, rectify=false)</code></li> <li><code>triangular(lowerLimit = 0, mode = 1, upperLimit = 2)</code></li> <li><code>constant(value)</code></li> </ul> <p>All distributions functions provide common parameter defaults where possible, and are defined as extension functions of <code>org.kalasim.SimContext</code>. This makes the accessible in environment definitions, all simulation entities, as well as process definitions.</p> <p>The normal distribution can be  rectified, effectively capping sampled values at 0  (example <code>normal(3.days, rectify=true)</code>). This allows for  zero-inflated distribution models under controlled randomization.</p> <p>Example: <pre><code>object : Component() {\n    val waitDist = exponential(3.3) // this is bound to env.rg\n\n    override fun process() = sequence {\n        hold(waitDist()) \n    }\n} \n</code></pre></p> <p>As shown in the example, probability distributions can be sampled with invoke <code>()</code>.</p>"},{"location":"basics/#constant-random-variables","title":"Constant Random Variables","text":"<p>The API also allow to model constant random variables using <code>const(&lt;some-value&gt;)</code>. These are internally resolved as <code>org.apache.commons.math3.distribution.ConstantRealDistribution</code>. E.g. consider the time until a request is considered as failed:</p> <pre><code>val dist =  constant(3)\n// create a component generator with a fixed inter-arrival-time\nComponentGenerator(iat = dist) { Customer() }\n</code></pre>"},{"location":"basics/#duration-distributions","title":"Duration Distributions","text":"<p>Typically randomization in a discrete event simulation is realized by stochastic sampling of time durations. To provide a type-safe API for this very common usecase, all continuous distributions are also modeled to sample <code>kotlin.time.Duration</code> in addtion <code>Double</code>. Examples:</p> <pre><code>// Create a uniform distribution between 3 days and 4 days and a bit  \nval timeUntilArrival = uniform(lower = 3.days, upper = 4.days + 2.hours)\n\n// We can sample distributions by using invoke, that is () \nval someTime : Duration= timeUntilArrival() \n\n// Other distributions that support the same style\nexponential(mean = 3.minutes)\n\nnormal(mean = 10.days, sd = 1.hours, rectify=true)\n\ntriangular(lowerLimit = 0.days, mode = 2.weeks, upperLimit = 3.years)\n\nconstant(42.days)\n</code></pre> <p>Tip</p> <p>In addition to dedicated duration distributions, all numeric distributions can be converted to duration distributions using duration unit indicators suffices. E.g <code>normal(23).days</code> </p>"},{"location":"basics/#enumerations","title":"Enumerations","text":"<p>Very often when working out simulation models, there is a need to sample with controlled randomization, from discrete populations, such as integer-ranges, IDs, enums or collections. Kalasim supports various integer distributions, uuid-sampling, as well as type-safe enumeration-sampling.</p> <ul> <li><code>discreteUniform(lower, upper)</code> - Uniformly distributed integers in provided interval</li> <li><code>uuid()</code> - Creates a random-controlled - i.e. deterministic - series of universally unique IDs (backed by <code>java.util.UUID</code>)</li> </ul> <p>Apart fom numeric distributions, also distributions over arbitrary types are supported with <code>enumerated()</code>. This does not just work with <code>enums</code> but with arbitrary types including data classes.</p> <pre><code>enum class Fruit{ Apple, Banana, Peach }\n\n// create a uniform distribution over the fruits\nval fruit = enumerated(values())\n// sample the fruits\nval aFruit: Fruit = fruit()\n\n// create a non-uniform distribution over the fruits\nval biasedFruit = enumerated(Apple to 0.7, Banana to 0.1, Peach to 0.2 )\n// sample the distribution\nbiasedFruit()\n</code></pre>"},{"location":"basics/#custom-distributions","title":"Custom Distributions","text":"<p>Whenever, distributions are needed in method signatures in <code>kalasim</code>, the more general interface <code>org.apache.commons.math3.distribution.RealDistribution</code> is being used to support a much wider variety of distributions if needed. So we can also use other implementations as well. For example</p> <pre><code>ComponentGenerator(iat = NakagamiDistribution(1, 0.3)) { Customer() }\n</code></pre>"},{"location":"changes/","title":"Kalasim Release History","text":""},{"location":"changes/#12","title":"1.2","text":"<p>Released 2026-01-03</p> <ul> <li> <p>Significantly improved process bootstrap performance for models with many components (&gt;1M) </p> </li> <li> <p>Adding better reflection logic to identify process definitions</p> </li> <li>Moved consistency checks into ASSERT mode </li> <li>Faster (cached) detection of process definition</li> <li>Added  new <code>EnvProvider</code> interface for more direct coupling of components to the </li> </ul>"},{"location":"changes/#112","title":"1.1.2","text":"<p>Released 2026-01-02</p> <ul> <li>Fixed <code>interupt()</code> to work better in combination with <code>wait()</code></li> <li>Updated jvm baseline to 21</li> <li>Updated dependencies</li> </ul>"},{"location":"changes/#110","title":"1.1.0","text":"<ul> <li>Updated all dependencies</li> <li>Added duplicate check to avoid reregistering components in <code>Environment</code></li> <li>Removed deprecated API</li> <li>Test fixes</li> </ul>"},{"location":"changes/#103","title":"1.0.3","text":"<ul> <li>Added slicing for <code>CategoryTimeline</code></li> </ul>"},{"location":"changes/#10","title":"1.0","text":"<p>Major &amp; Breaking API Changes</p> <ul> <li>Most importantly we have migrated the API to use <code>org.kalasim.SimTime</code> to track simulation. <code>SimTime</code> is a simple typealias for <code>kotlinx.datetime.Instant</code>, effectively giving users the full flexibility of using a well designed and established date-time concept. <code>org.kalasim.TickTime</code> is still available for backward compatibility reasons, but is opt-in or required to subclass <code>TickedComponent</code>.</li> <li>Simplified the configurability for tracking of entity timelines and statistics. It's now more direct via constructor parameters in addition to environment defaults</li> <li>#68 Improved arithmetics of metric timelines</li> <li>#65 provide a statistics API for the internal event bus</li> <li>#69 Allow activating processes with argument in a type-safe manner</li> </ul> <p>Minor improvements</p> <ul> <li>#51 Added <code>description</code> for better readiability when supepending exeuction for simulatoin states using <code>wait()</code> </li> <li>#56 Improved support for duration distributions </li> <li>Expose <code>Environment.getOrNull&lt;T&gt;()</code> from koin to check for presence of registered dependencies in simulation environment</li> <li>#46 clarify use of collect with filter </li> <li>#52 Improved visualization of metric timelines to support zoom range</li> <li>#67 &amp; #64 Added more safety guard mechanisms to prevent context violations when branching component processes.</li> </ul> <p>Starting with this release we have switched to calendar versioning for better clarity regarding our release density, timing and schedule.</p>"},{"location":"changes/#v011","title":"v0.11","text":"<p>Major improvements </p> <ul> <li>significantly improved library performance</li> <li>Added <code>Int.Weeks</code> extension</li> <li>Introduced suspendable <code>join(components: List&lt;Component&gt;)</code> to wait for other components to become <code>DATA</code> </li> </ul> <p>Documentation &amp; Examples * New Example Shipyard - Multipart assembly</p>"},{"location":"changes/#v010","title":"v0.10","text":"<p>Released 2023-06-16</p> <p>Breaking API Changes</p> <ul> <li>tick metrics and component-logger are now configured and not enabled via constructor parameter any longer (to minimize constructor complexity)</li> </ul> <p>Improvements</p> <ul> <li>More robust dependency injection</li> </ul> <p>Performance</p> <ul> <li>Added jmh benchmark-suite and reporting</li> </ul> <p>Documentation</p> <ul> <li>Continued migration to <code>Duration</code> as replacement for <code>Number</code> in <code>hold()</code>, <code>wait()</code> etc.  </li> </ul>"},{"location":"changes/#v09","title":"v0.9","text":"<p>Released at 2023-04-13</p> <p>Major</p> <ul> <li>#49 Changed API to always favor <code>kotlin.time.Duration</code> to express durations. Previously untyped <code>Numbers</code> were used that often led to confusion in larger simulations models. Evey simulation environment has now a <code>DurationUnit</code> such as seconds, hours, etc.  (defaulting to minutes if not specified). </li> <li>New opt-in annotations were introduced to prevent use of untyped duration arguments in interaction functions such as ``</li> <li>Migrated use of <code>Instant</code> to <code>kotlinx.datetime.Instant</code> for better API consistency</li> <li>New sampling functions to sample durations directly: <code>val uni = uniform(5.minutes, 2.hours); uni() // results in Duration</code></li> </ul> <p>Minor </p> <ul> <li>Overwrite <code>shuffled()</code> and <code>random()</code> as extensions on <code>Collection&lt;T&gt;</code> in simulation entities to enable better control over randomization by default</li> </ul>"},{"location":"changes/#v08","title":"v0.8","text":"<p>Released announced at 2022-09-27</p> <p>Milestone Enhancements</p> <ul> <li>Implemented honor policies allowing for more configurable request queue consumption <pre><code>val r  = Resource(honorPolicy = RequestHonorPolicy.StrictFCFS)\n</code></pre></li> <li>Added Timeline Arithmetics. It is now possible to perform stream arithmetics on timeline attributes</li> <li>Introduced different capacity modes if resource requests exceed resource capacity. <pre><code>val tank  = DepletableResource(capacity=100, initialLevel=60)\n\nput(gasSupply, 50, capacityLimitMode = CapacityLimitMode.CAP)\n</code></pre></li> <li>#23 Added support for duration extensions introduced in kotlin v1.6 to express durations more naturally with <code>2.hours</code>, <code>3.minutes</code> and so on. It is now possible to use <code>java.time.Instant</code> and <code>kotlin.time.Duration</code> in <code>Component.hold()</code> and <code>Environment.run</code>.  <pre><code>createSimulation{\n    object: Component{\n        val driver = Resource(2) \n        override fun process() = sequence {\n            request(driver) {\n                hold(23.minutes)\n            }\n            hold(3.hours)\n        }\n\n    }\n}.run(2.5.days) // incl. fractional support\n</code></pre></li> </ul> <p>Major Enhancements</p> <ul> <li>#37 Simplified process activation in process definitions  </li> <li>#34 Added support for triangular distributions</li> <li>#43 Simplified states to consume predicates directly in <code>wait()</code></li> <li>#27 Made resource events more informative and consistent. These event now include a request-id to enable simplified bottleneck analyses  </li> <li>Added <code>RequestScopeContext</code> to honor-block of <code>request</code> including <code>requestingSince</code> time</li> <li>#35 Improved support for asynchronous event consumption (contributed by pambrose via PR)</li> <li>Reduced memory requirements of resource monitoring by 50% by inferring <code>occupancy</code> and <code>availability</code> using Timeline Arithmetics</li> <li>#38 Extended and improved API support for depletable resources. </li> <li>Added <code>ComponentQueue.asSortedList()</code> to sorted copy of underlying priority queue </li> <li>Ported data-frame-support from krangl to the more modern kotlin-dataframe.</li> </ul> <p>Minor enhancements</p> <ul> <li>#47 Added entity auto-indexing to allow for more descriptive names</li> <li>#50 Fixed <code>trigger()</code></li> <li>Introduced more event-types and improved structured logging capabilities</li> <li>Renamed all <code>info</code> attributes to <code>snapshot</code> to convey intent better</li> <li>Unified naming resource attributes</li> <li>#28 Added support API to sample UUIDs with engine-controlled randomization </li> <li>Added <code>capacity</code> to component collections</li> <li>Reworked distribution support API for better API experience to enable controlled randomization in process models</li> <li>Removed <code>Resource.release()</code> because of incomplete and unclear semantics</li> <li>#53 Generified <code>MetricsTimeline</code></li> </ul> <p>Documentation</p> <ul> <li>#38 Rewritten gas-station example to illustrate depletable resource usage</li> <li>Added new datalore example workbook: Extended Traffic</li> <li>Reworked The Office Tower to include better model description and animation</li> <li>New: Lunar Mining model to illustrate new animation toolbox of kalasim  </li> </ul>"},{"location":"changes/#v07","title":"v0.7","text":"<p>Released 2021-11-27</p> <p>See release announcement</p> <p>Major enhancements</p> <ul> <li>Reworked event &amp; metrics logging API</li> <li>Introduced <code>ComponentList</code></li> <li>Implemented ticks metrics monitor (fixes #9)</li> <li>New timeline and activity log  attributes to resources for streamlined usage and capacity analysis  </li> <li>Extended <code>display()</code> support API on all major components and their collections (including <code>Resource</code>, <code>Component</code> or <code>List&lt;Component&gt;</code>, <code>MetricTimeline</code>) (fixes #18)</li> <li>Thread-local context registry enabled via Koin Context Isolation (fixes #20)</li> <li>Dramatically improved simulation performance</li> </ul> <p>Documentation</p> <ul> <li>New chapter about collections</li> <li>Revised resource documentation</li> <li>Rewritten ATM example to better illustrate parallelization and generators</li> <li>New example Bridge Games</li> <li>Started new canonical complex simulation example: emergency room</li> </ul> <p>Minor enhancements</p> <ul> <li>Added possibility stop a simulation from a process definition using <code>`stopSimulation</code></li> <li>Introduced <code>AssertMode</code>s (<code>Full</code>, <code>Light</code> (default), <code>None</code>) to enable/disable internal consistency checks. This will optimize performance by another ~20% (depending on simulation logic)</li> <li>Improved request priority API</li> <li>Allow for runtime reconfiguration of <code>ClockSync</code> to enable adjustable simulation speed</li> <li>Lifted <code>Component</code> sub-type requirement from <code>ComponentQueue</code></li> <li>Fixed <code>oneOf</code> in <code>request()</code></li> <li>Redesigned <code>honorBlock</code> in <code>request()</code> to return <code>Unit</code> and to provide claimed resource via <code>it</code> <pre><code>request(doctorFoo, doctorBar, oneOf = true) { doctor -&gt;\n    println(\"patient treated by $doctor\")\n}\n</code></pre></li> <li>Added <code>RealDistribution.clip</code> to allow zero-inflated distribution models with controlled randomization</li> </ul> <p>Breaking changes</p> <ul> <li>Removed <code>components</code> from <code>Environment</code> and created <code>componentCollector</code> as optional replacement</li> <li>Redesigned events &amp; metrics API </li> <li>Updated to <code>koin</code> v3.1 (fixes #15): <code>GlobalContext</code> has been replaced with <code>DependencyContext</code></li> <li>Established use of <code>SimTime</code> across the entire API to disambiguate simulation time instants from durations, which are still modelled as <code>Double</code></li> <li>Changed <code>Component.now</code>and <code>Environment.now</code> to new value class <code>SimTime</code> for better type safety</li> <li>Simplified <code>ClockSync</code> API by removing redundant <code>speedUp</code> parameter</li> <li><code>Component.status</code> has been renamed to <code>Component.componentState</code> to enable extending classes to use the property name <code>status</code> for domain modelling</li> <li>Removed requirement to implement <code>info</code> in <code>SimulationEntity</code></li> <li>Moved stochastic distributions support API to from <code>Component</code> to <code>SimulationEntity</code></li> <li>Removed <code>Component::setup</code> because the user can just use an <code>init{}</code> block instead</li> <li>Migrated release channel from jcenter to maven-central</li> </ul>"},{"location":"changes/#v06","title":"v0.6","text":"<p>Released 2021-02-12 -&gt; Updated to v0.6.6 on 2021-05-05</p> <p>Major Enhancements</p> <ul> <li> <p>Added <code>selectResource()</code> to select from resources with policy <pre><code>val doctors = List(3) { Resource() }\nval selected = selectResource( doctors, policy = ShortestQueue )\n</code></pre></p> </li> <li> <p>New suspending <code>batch</code> interaction to group an entity stream into blocks <pre><code>val queue = ComponentQueue&lt;Customer&gt;()\nval batchLR: List&lt;Customer&gt; = batch(queue, 4, timeout = 10)\n</code></pre></p> </li> <li> <p>Added option to configure a tick to wall time transformer  <pre><code>createSimulation {\n    tickTransform = OffsetTransform(Instant.now(), DurationUnit.MINUTES)\n\n    run(Duration.ofMinutes(90).asTicks())\n    println(asSimTime(now))\n}\n</code></pre></p> </li> <li> <p>Added lifecycle records to streamline component state analyses</p> </li> <li> <p>Changed <code>ComponentGenerator</code> to allow generating arbitrary types (and not just <code>Component</code>s) <pre><code>ComponentGenerator(uniform(0,1)){ counter -&gt; \"smthg no${counter}\"}\n</code></pre></p> </li> <li> <p>Added <code>forceStart</code> to <code>ComponentGenerator</code> to define if an arrival should be happen when it is activated for the first time</p> </li> <li> <p>Changed scheduling priority from <code>Int</code> to inline class <code>Priority</code> (with defaults <code>NORMAL</code>, <code>HIGH</code>, <code>LOW</code>) in all interaction methods for more typesafe API</p> </li> <li> <p>Started bundled simulations for adhoc experimentation and demonstration by adding M/M/1 queue <code>MM1Queue</code></p> </li> <li> <p>Added support for pluggable visualization backend. Currently kravis and lets-plot are supported. For jupyter-notebook examples mm1-queue analysis <pre><code>// simply toggle backend by package import\nimport org.kalasim.plot.letsplot.display\n// or\n//import org.kalasim.plot.kravis.display\n\nMM1Queue().apply {\n    run(100)\n    server.claimedMonitor.display()\n}\n</code></pre></p> </li> <li> <p>New Example: \"The ferryman\"</p> </li> <li>New Example: Office Tower</li> </ul>"},{"location":"changes/#v05","title":"v0.5","text":"<p>Released 2021-01-12</p> <p>Major Enhancements</p> <ul> <li>Added first jupyter notebook example</li> <li>New depletable resource type</li> <li>New statistical distributions API</li> <li>New more structured event logging. See user manual</li> <li>Implemented support for real-time simulations</li> <li>New example Dining Philosophers</li> <li>New example Movie Theater</li> <li>New API to add dependencies in simulation context using <code>dependency {}</code></li> </ul> <p>Notable Fixes</p> <ul> <li>Fixed <code>failAt</code> in <code>request</code></li> </ul>"},{"location":"changes/#v04","title":"v0.4","text":"<p>Released 2021-01-03</p> <p>Major Enhancements</p> <ul> <li>Implemented <code>interrupt</code> interaction</li> <li>Reworked documentation and examples</li> <li>Implemented <code>standby</code></li> <li>Implement disable/enable for monitors</li> <li> <p>Yield internally, to simplify process definitions <pre><code>// before\nobject : Component() {\n    override fun process() = sequence { yield(hold(1.minutes)) }\n}\n\n// now\nobject : Component() {\n    override fun process() = sequence { hold(1.hours) }\n}\n</code></pre></p> </li> <li> <p>Made <code>scheduledTime</code> nullable: Replaced <code>scheduledTime = Double.MAX_VALUE</code> with <code>null</code> where possible to provide better mental execution model</p> </li> <li>Provide lambda parameter to enable auto-releasing of resources <pre><code>// before\nobject : Component() {\n    override fun process() = sequence { \n        request(r)\n        hold(1)\n        release(r)\n    }\n}\n\n// now\nobject : Component() {\n    override fun process() = sequence { \n        request(r){\n            hold(1)\n        }\n    }\n}\n</code></pre></li> <li>Implemented <code>Environment.toString</code> to provide json description</li> <li>Various bug-fixes</li> </ul>"},{"location":"changes/#v03","title":"v0.3","text":"<ul> <li>Reimplemented monitors</li> <li>Continued salabim core API reimplementation</li> <li>Fixed: Decouple simulation with different koin application contxts</li> </ul>"},{"location":"changes/#v02","title":"v0.2","text":"<ul> <li>Reimplement core salabim examples in kotlin</li> <li>Port all salabim examples</li> <li>Started MkDocs manual</li> </ul>"},{"location":"changes/#v01","title":"v0.1","text":"<ul> <li>Reimplement salabim's main component lifecycle</li> <li>Add timing API</li> </ul>"},{"location":"collections/","title":"Collections","text":"<p>A very common element of discrete simulation models, are queues of elements that are consumed by downstream components. A basic example would be the waiting line in a bank.</p> <p>Clearly, the JVM and Kotlin provide a very rich collection API ecosystem. However, <code>kalasim</code> is providing its own implementations for <code>List</code> and <code>Queue</code> with <code>ComponentList</code> and <code>ComponentQueue</code> respectively, that are backed with standard implementation but add additional metrics and tracking to allow statistical analysis. If such functionality is not needed in a particular simulation model, standard collection implementation can be used as well without any restriction.  </p>"},{"location":"collections/#queue","title":"Queue","text":"<p><code>kalasim</code> provides an instrumented queue implementation <code>ComponentQueue</code> on top of the JVM's PriorityQueue  to model waiting lines etc. Conceptual our implementation is very similar to <code>salabim</code>'s queue.</p> <p>A typical use case would be a generator process (material, customers, etc.) that is consumed by other components. By definition, a generator is a <code>Component</code> that contains at least one yield in its process definition. In the following example a generator is creating new <code>Customer</code>s which are entering a waiting line <code>Queue</code>. This queue is consumed by a clerk which take one customer at a time and goes on <code>hold</code> for processing. See here for the complete implementation.</p> <p>sequenceDiagram EventLoop-&gt;&gt;CustomerGenerator: Continue generator process CustomerGenerator-&gt;&gt;Customer: Create new Customer CustomerGenerator--&gt;&gt;EventLoop: Reschedule for later  Customer-&gt;&gt;Queue: Enter waiting line Clerk-&gt;&gt;Queue: Pull next customer Clerk--&gt;&gt;EventLoop: hold vor n time units for processing Examples</p> <ul> <li>ATM Queue</li> </ul>"},{"location":"collections/#comparator","title":"Comparator","text":"<p>By default, the <code>ComponentQueue</code> is sorted by priority and enter-time. To provide a custom ordering scheme, the user can supply her own comparator easily</p> <pre><code>val cq = ComponentQueue(comparator = compareBy&lt;Patient&gt; { it.severity })\n\n// or using a chained comparator\nval cq2 = ComponentQueue(comparator = compareBy &lt;Patient&gt;{ it.severity }.thenBy { it.type })\n</code></pre>"},{"location":"collections/#batching","title":"Batching","text":"<p>Queues can be consumed in a batched manner using the <code>batch()</code>. See \"The Ferryman\" for a worked out example and its API documentation.</p>"},{"location":"collections/#list","title":"List","text":"<p>As alternative to the ordered queue, <code>kalasim</code> also provides a similarly instrumented list implementation with <code>ComponentList</code>. It's only providing very basic FiFo queue characteristics with <code>poll()</code> supported by its backend. </p> <p>The main intent for <code>ComponentList</code> are more sophisticated use-cases that can not be modelled with a single queue. Examples are </p> <ul> <li>Machine scheduling with more than instance</li> <li>Service models with different</li> </ul> <p>In such cases, a simple <code>Comparator</code> (even a chained one) are often insufficient to model the complex scheduling requirements.</p>"},{"location":"collections/#metrics","title":"Metrics","text":"<p>Both, the <code>ComponentList</code> and the <code>ComponentQueue</code> provide a similar set of built-in metrics</p> <p>Monitors</p> <ul> <li><code>queueLengthMonitor</code> tracks the queue length level across time</li> <li><code>lengthOfStayMonitor</code> tracks the length of stay in the queue over time</li> </ul> <p>Statistics</p> <ul> <li><code>stats</code> - Current state snapshot of queue statistics regarding length and length of stay</li> <li><code>info</code> - Json-structured summary of the list/queue</li> </ul>"},{"location":"collections/#capacity","title":"Capacity","text":"<p>Collections support a <code>capacity</code> and an accompanying <code>capacityTimeline</code> to set a maximum capacity. If this capacity is exceeded a <code>CapacityExceededException</code> is being thrown. </p> <p>A capacity can be reduced (similar to resources) by setting a new one</p> <pre><code>val queue = ComponentQueue(capacity=5)\nqueue.capacity = 10\n</code></pre> <p>When setting a capacity that is lower than the current collection size, a <code>CapacityExceededException</code> is being thrown. </p>"},{"location":"component/","title":"Component","text":"<p>Components are the key elements of a simulation. By providing a process definition of the business process in study, components allow modeling the interplay with other simulation components as well as its timing.</p> <p>Components can be in different lifecycle state. An <code>ACTIVE</code>  component has one or more process definitions of which one was activated at some point earlier in time. </p> <p>If a component has an associated process definition, we can schedule it for execution using  <code>activate()</code>. This will also change its state to become active <code>ACTIVE</code>, </p> <p>An <code>ACTIVE</code> component can become <code>DATA</code> either with a <code>cancel()</code> or by reaching the end of its process definition.</p> <p>It is very easy to create a <code>DATA</code> components which can be useful to model more passive elements in a model (such as production material).</p> <pre><code>val component = Component()\n</code></pre> <p>Components will interact with each other through a well-defined vocabulary of process interaction methods.</p> <p>Info</p> <p>By default, Components will be named automatically, using the pattern <code>[Class Name].[Instance Number]</code> unless a custom name is provided via the <code>name</code> parameter in <code>Component(name=\"Foo\")</code>. Kalasim also supports auto-indexing if a provided component name ends with a dash <code>-</code>, dot <code>.</code> or underscore <code>_</code>. E.g. A first <code>Component(\"Foo-\")</code> will be named <code>Foo-1</code>, a second one <code>Foo-2</code> and so on.</p>"},{"location":"component/#process-definition","title":"Process Definition","text":"<p>Although it is possible to create a component directly with <code>val x = Component()</code>, this does not encode any simulation mechanics a there is process definition defining how the <code>x</code> will interact with the simulation environment. So, nearly always we define our simulation entities by extending <code>Component</code> and by providing a process definition which details out the component's life cycle:</p> <p>Important</p> <p>The process definition of a component defines its dynamics and interplay with other simulation entities. Writing down the process definition is the key modelling task when using <code>kalasim</code>.</p> <p>If there is no process definition, a component will stay passive. Techncially, it is refrerred to as a <code>DATA</code> component.</p> <p>There are 3 supported methods to provide a process definition.</p>"},{"location":"component/#1-extend-process","title":"1. Extend <code>process</code>","text":"<p>Let's start with the most common method. In order to define an <code>ACTIVE</code>  component it is necessary to extend <code>org.kalasim.Component</code> to provide (at least) one sequence generator method, normally called <code>process</code>:</p> <pre><code>class Car: Component(){\n    override fun process() = sequence {\n        wait(customerArrived)\n\n        request(driver){\n            hold(4, \"driving\")\n        }\n    }\n}\n</code></pre> <p>If we then later say <code>val car = Car()</code>, a component is created, and it is scheduled for execution within kalasim's event loop. The <code>process</code> method is nearly always, but not necessarily a generator method  (i.e. it has at least one <code>yield</code> statement), so it contains suspension points where execution can be stalled. </p> <p>It is also possible to set a time at which the component (<code>car</code>) becomes active, like <code>val car = Car(delay=10)</code>. This requires an additional constructor argument to be passed on to <code>Component</code> as in <code>class Car(delay:Number): Component(delay=delay)</code>.</p> <p>Creation and activation are by default combined when creating a new <code>Component</code> instance:</p> <pre><code>val car1 = Car()\nval car2 = Car()\nval car3 = Car()\n</code></pre> <p>This causes three cars to be created and to be activated, so these instances are scheduled for execution in the simulation's event queue.</p> <p>Info</p> <p>In some situations, automatic activation of the process definition may not be needed or desired. If so, even in presence of a <code>process</code> or <code>repeatedProcess</code> method, you can disable the automatic activation (i.e. make it a data component), by specifying <code>Component(process = Component::none)</code>.</p> <p>Normally, any process definition will contain at least one <code>yield</code> statement. By doing so, the component can hand-back control to the simulation engine at defined points when a component needs to wait. Typically, the user must not use <code>yield</code> directly, but rather the provided process interaction methods.</p>"},{"location":"component/#2-extend-repeatedprocess","title":"2. Extend <code>repeatedProcess</code>","text":"<p>Another very common pattern when writing down process definitions, iteratively executed processes. This could be modelled directly as described above using <code>process</code>. But as shown in the following example, this lacks somewhat lacks conciseness: </p> <pre><code>class Machine : Component(){\n    override fun process() = sequence {\n        while(true) {\n          wait(hasMaterial)\n          hold(7, \"drilling\")\n        }\n    }\n}\n</code></pre> <p>Luckily, this can be expressed more elegantly with <code>repeatedProcess</code>:</p> <pre><code>class Machine : Component(){\n    override fun repeatedProcess() = sequence {\n        wait(hasMaterial)\n        hold(7, \"drilling\")\n    }\n}\n</code></pre>"},{"location":"component/#3-process-reference","title":"3. Process Reference","text":"<p>A component may be initialized to start at another process definition method. This is achieved by passing a reference to this method which must be part of the component's class definition, like <code>val car = Car(process = Car::wash)</code>.</p> <p>It is also possible to prepare multiple process definition, which may become active later by means of an <code>activate()</code> statement:</p> <pre><code>////CraneProcess.kts\nimport org.kalasim.*\n\nclass Crane(\n    process: GeneratorFunRef? = Component::process\n) : Component(process = Crane::load) {\n    fun unload() = sequence&lt;Component&gt; {\n        // hold, request, wait ...\n    }\n\n    fun load() = sequence&lt;Component&gt; {\n        // hold, request, wait ...\n    }\n}\n\ncreateSimulation {\n    val crane1 = Crane() // load will be activated be default\n\n    val crane2 = Crane(process = Crane::load) // force unloading at start\n\n    val crane3 = Crane(process = Crane::unload) // force unloading at start\n    crane3.activate(process = Crane::load) // activate other process\n}\n</code></pre> <p>Effectively, creation and start of <code>crane1</code> and <code>crane2</code> is the same.</p>"},{"location":"component/#inlining-subprocesses","title":"Inlining Subprocesses","text":"<p>To run/consume/inline another process definition, we can use<code>yieldAll(subProcess())</code> to inline <code>subProcess()</code> defined for the same component. This allows to inline the entire process definition in a blocking manner. Here's an example how to do so:</p> <pre><code>//import org.kalasim.*\nimport kotlin.time.Duration.Companion.minutes\n\ncreateSimulation {\n    enableComponentLogger()\n\n    object : Component() {\n\n        override fun process() = sequence {\n            hold(1.minute)\n            // to consume the sub-process we use yieldAll\n            yieldAll(subProcess())\n            // it will continue here after the sub-process has been consumed\n            hold(2.minutes)\n        }\n\n        fun subProcess(): Sequence&lt;Component&gt; = sequence {\n            hold(3.minutes)\n        }\n    }\n\n    run()\n}\n</code></pre>"},{"location":"component/#toggling-processes","title":"Toggling processes","text":"<p>It's a very effective tool in discrete simulation, to toggle the process definition of a component at runtime. Using <code>activate()</code> we can toggle processes very effectively in a simulation model. There are 3 ways to do so</p> <ol> <li>From with a component's process defintion</li> <li>Within another component process defintion</li> <li>Outside of any process definition.</li> </ol> <p>The following example illustrates these examples as well as process inlining:</p> <p><pre><code>////Restaurant.kts\nimport org.kalasim.*\nimport kotlin.time.Duration.Companion.hours\nimport kotlin.time.Duration.Companion.minutes\n\ndata class Recipe(val name: String) {\n    override fun toString() = name\n}\n\nclass Customer : Component() {\n    val restaurant  = get&lt;Restaurant&gt;()\n\n    override fun process() = sequence&lt;Component&gt; {\n        hold(3.hours + 15.minutes) // arrive somewhen\n\n        restaurant.activate(process=Restaurant::cookSomething, Recipe(\"pasta\"))\n\n        hold(30.minutes,\"drink something while waiting for food\")\n\n        // wait for the food preparation to complete\n        join(restaurant)\n\n        //order something else\n        restaurant.activate(process=Restaurant::specialOffer)\n    }\n}\n\nclass Restaurant : Component() {\n\n    override fun process(): Sequence&lt;Component&gt; = sequence {\n        hold(2.hours, \"opening restaurant\")\n    }\n\n    fun cookSomething(recipe: Recipe) = sequence {\n        hold(10.minutes, \"preparing $recipe\")\n\n        log(\"dinner's ready! I am serving $recipe today\")\n    }\n\n    fun specialOffer(): Sequence&lt;Component&gt; = sequence {\n        hold(5.minutes, \"selecting dish of the day\")\n\n        // We can activate another process from within a process definition\n        // Provide a recipe, set the `spicy` flag and delay activation by 5 minutes\n        activate(::cookSomethingSpecial, Recipe(\"cake\"), true, delay = 5.minutes)\n    }\n\n    fun cookSomethingSpecial(recipe: Recipe, spicy: Boolean) = sequence {\n        hold(20.minutes, \"preparing $recipe ...\")\n\n        yieldAll(prepareDesert()) // inline sub-process\n\n        log(\"special dinner's ready!\")\n        log(\"serving ${if(spicy) \"spicy\" else \"\"} $recipe and some desert\")\n    }\n\n    // another small process without any arguments\n    fun prepareDesert() = sequence {\n        hold(15.minutes, \"making a pie\")\n    }\n}\n\ncreateSimulation {\n    enableComponentLogger()\n\n    // instantiate the simulation components\n    val restaurant = dependency { Restaurant() }\n\n    // create customer\n    Customer()\n\n    // run the model\n    run()\n\n    // activate process with arguments from outside a process definition\n    restaurant.activate(\n        process = Restaurant::cookSomething,\n        processArgument = Recipe(\"lasagne\")\n    )\n\n    // and run again\n    run()\n}\n</code></pre> Notably, we can provide process arguments here in a typesafe manner.</p>"},{"location":"component/#lifecycle","title":"Lifecycle","text":"<p>A simulation component is always in one of the following states modelled by <code>org.kalasim.ComponentState</code>:</p> <ul> <li><code>CURRENT</code> - The component's process is currently being executed by the event queue</li> <li><code>SCHEDULED</code> - The component is scheduled for future execution</li> <li><code>PASSIVE</code> - The component is idle</li> <li><code>REQUESTING</code> - The component is waiting for a resource requirement to be met</li> <li><code>WAITING</code> - The component is waiting for a state predicate to be met</li> <li><code>STANDBY</code> - The component was put on standby</li> <li><code>INTERRUPTED</code> - The component was interrupted</li> <li><code>DATA</code> - The component is non of the active states above. Components without a <code>process</code> definition are always in this state.</li> </ul> <p>A component's status is managed via the property <code>component.componentState</code>, and is automatically tracked with a level monitor named <code>component.statusTimeline</code>.</p> <p>The <code>statusMonitor</code> can be consumed in different ways. It possible to check how long a component has been in a particular state with</p> <p><pre><code>val passiveDuration = component.statusMonitor[ComponentState.PASSIVE]\n</code></pre> Also, it is possible to print a histogram with all the statuses a component has been in with</p> <pre><code>component.statusMonitor.printHistogram()\n</code></pre> <p>Accumulated times in a particular state can be obtained with <code>summed()</code> and be printed to console or displayed with the selected graphics backend</p> <pre><code>val timeInEachState = component.statusMonitor.summed()\n\ntimeInEachState.printConsole()\ntimeInEachState.display()\n</code></pre> <p></p>"},{"location":"component/#process-interaction","title":"Process Interaction","text":"<p>The scheme below shows how interaction relate to component state transitions:</p> from/to data current scheduled passive requesting waiting standby interrupted data activate<sup>1</sup> activate current process end yield hold yield passivate yield request yield wait yield standby . yield cancel yield activate scheduled cancel next event hold passivate request wait standby interrupt . activate passive cancel activate<sup>1</sup> activate request wait standby interrupt . hold<sup>2</sup> requesting cancel claim honor activate<sup>3</sup> passivate request wait standby interrupt . time out activate<sup>4</sup> waiting cancel wait honor activate<sup>5</sup> passivate wait wait standby interrupt . timeout activate<sup>6</sup> standby cancel next event activate passivate request wait interrupt interrupted cancel resume<sup>7</sup> resume<sup>7</sup> resume<sup>7</sup> resume<sup>7</sup> resume<sup>7</sup> interrupt<sup>8</sup> . activate passivate request wait standby <ol> <li> Via <code>scheduled()</code></li> <li> Not recommended</li> <li> With <code>keepRequest = false</code> (default)</li> <li> With <code>keepRequest = true</code>. This allows to set a new time out</li> <li> With <code>keepWait = false</code> (default)</li> <li> With <code>keepWait = true</code>. This allows to set a new timeout</li> <li> State at time of interrupt</li> <li> Increases the <code>interruptLevel</code></li> </ol>"},{"location":"component/#hold","title":"hold","text":"<p>This method is utilized to suspend a component for a specific duration of simulation time. It changes that the state of a - usually <code>current</code> - component to <code>scheduled</code>. By invoking the hold method, control is returned from the process definition back to the simulation engine. After the specified hold duration, the engine will resume the execution of the process definition. This becomes a crucial method in <code>kalasim</code>, as it dictates the temporal flow of the overall process.</p> <p>Here's a basic example illustrating this process:</p> <pre><code>object : Component(\"Something\") {\n    override fun process() = sequence {\n        hold(10.minutes, description = \"some action\")\n        // ^^ This is telling kalasim to suspend execution of this process \n        // for 10 simulation minutes\n\n        // ... 10 minutes later ...\n        // After these 10 minutes, it will continue execution of the process\n        hold(1.minutes, description = \"some other action \")\n    }\n}\n</code></pre> <p>Supported parameters in <code>hold()</code> are</p> <ul> <li><code>duration</code> - The duration for which the component should be held.</li> <li><code>description</code> - An optional description for the hold operation.</li> <li><code>until</code> - The simulation time until which the component should be held. If provided, the component will be held until the specified simulation time.</li> <li><code>priority</code> - The priority of the hold operation. A higher priority value indicates a higher priority. Defaults to <code>NORMAL</code>.</li> <li><code>urgent</code> - A flag indicating whether the hold operation is urgent. If set to true, the component will be scheduled with the highest possible priority. Defaults to <code>false</code>.</li> </ul> <p>Either <code>duration</code> or <code>until</code> must be specified when calling <code>hold()</code> to indicate the intended delay.</p>"},{"location":"component/#state-contract","title":"State Contract","text":"<p>The state contract when calling <code>hold()</code> is as follows</p> <ul> <li>If the component is <code>CURRENT</code>, it will suspend execution internally, and the component becomes scheduled for the specified time</li> <li>If the component to be held is passive, the component becomes scheduled for the specified time.</li> <li>If the component to be held is scheduled, the component will be rescheduled for the specified time, thus   essentially the same as activate.</li> <li>If the component to be held is standby, the component becomes scheduled for the specified time.</li> <li>If the component to be activated is requesting, the request will be terminated, the attribute failed   set and the component will become scheduled. It is recommended to use the more versatile activate method.</li> <li>If the component to be activated is waiting, the wait will be   terminated, the attribute failed set and the component will become scheduled. It is recommended to   use the more versatile activate method.</li> <li>If the component is interrupted, the component will be activated at the specified time.</li> </ul>"},{"location":"component/#activate","title":"activate","text":"<p><code>activate()</code> will schedule execution of a process definition at the specified time. If no time is specified, execution will be scheduled for the current simulation time. If you do not specify a process, the current process will be scheduled for continuation. If a <code>process</code> argument is provided, the process will be started (or restarted if it is equal to the currently active process).</p> <pre><code>Car() // default to process=Component::process or Component::repeatedProcess   \nCar(process=Component::none) // no process, which effectivly makes the car DATA     \n\nval car = Car(process=Car::driving) // start car in driving mode  \n\n// stop driving (if still ongoing) and activate refilling process\ncar1.activate(process=Car::refilling)\n\n// activate defined process if set, otherwise error\ncar0.activate()  \n</code></pre>"},{"location":"component/#parameters","title":"Parameters","text":"<p>Supported parameters in <code>activate()</code></p> <ul> <li><code>process</code> - The name of the process to be started. If set to <code>None</code>, the process will not be changed. If the component is a data component, the generator function <code>process</code> will be used as the default process. Optionally type safe arguments can be provided to the generator function  via <code>processArgument</code> and <code>otherProcessArgument</code></li> <li><code>processArgument</code> - The argument to be passed to the process.</li> <li><code>at</code> - The schedule time. If omitted, no <code>delay</code> is used.</li> <li><code>delay</code> - The delay before starting the process. It uses a <code>Duration</code> object to specify the delay amount. The default value is <code>Duration.ZERO</code>.</li> <li><code>priority</code> - The priority level of the activation. It uses the <code>Priority</code> enumeration with options HIGH, NORMAL, and LOW. The default value is NORMAL.</li> <li><code>urgent</code> - Indicates whether the activation is urgent or not. If set to true, the activation will be treated as urgent. The default value is false.</li> <li><code>keepRequest</code> - Indicates whether to keep the activation request even after the process is started. If set to true, the activation request will be kept. The default value is false.</li> <li><code>keepWait</code> - Indicates whether to keep waiting for the process to complete before returning. If set to true, the activation will not return until the process is complete. The default value is false.</li> </ul>"},{"location":"component/#state-contract_1","title":"State Contract","text":"<p>The state contract when calling <code>hold()</code> is as follows</p> <ul> <li>If the component to be activated is <code>DATA</code>, unless provided with <code>process</code> the default <code>Component::process</code> will be scheduled at the specified time.</li> <li>If the component to be activated is <code>PASSIVE</code>, the component will be activated at the specified time.</li> <li>If the component to be activated is <code>SCHEDULED</code>, the component will get a new scheduled time.</li> <li>If the component to be activated is <code>REQUESTING</code>, the request will be   terminated, the attribute failed set, and the component will become scheduled. If keep_request=True   is specified, only the fail_at will be updated, and the component will stay requesting.</li> <li>If the component to be activated is <code>WAITING</code>, the wait will be   terminated, the attribute <code>failed</code> set, and the component will become scheduled. If <code>keepWait=true</code>   is specified, only the <code>failAt</code> will be updated, and the component will stay waiting.</li> <li>If the component to be activated is <code>STANDBY</code>, the component will get a new scheduled time and become   scheduled.</li> <li>If the component is <code>INTERRUPTED</code>, the component will be activated at the specified time.</li> </ul>"},{"location":"component/#misc","title":"Misc","text":"<p>Important</p> <p>It is not possible to <code>activate()</code> the <code>CURRENT</code> component without providing a <code>process</code> argument. <code>kalasim</code> will throw an error in this situation. The effect of a \"self\"-activate would be that the component becomes scheduled, thus this is essentially equivalent to the preferred hold method, so please use <code>hold</code> instead. The error is a safe-guard mechanism to prevent the user from unintentionally rescheduling the current component again. </p> <p>In situations where the current process need to be restarted, we can use activate <code>yield(activate(process = Component::process))</code> which will bypass the internal requirement that the activated component must not be <code>CURRENT</code>.</p> <p>Although not very common, it is also possible to activate a component at a certain time or with a specified delay:</p> <pre><code>ship1.activate(at=100)\nship2.activate(delay=50.minutes)\n</code></pre> <p>Note</p> <p>It is possible to use <code>activate()</code> outside of a process definition, e.g. to toggle processes after some time  </p> <p><pre><code>sim.run(10)\ncar.activate(process=Car::repair)\nsim.run(10)\n</code></pre> However, in most situations this is better modelled within a process definition.</p> <p>We can use <code>activate</code>  to toggle the active process of a component</p>"},{"location":"component/#passivate","title":"passivate","text":"<p>Passivate is the way to make a - usually <code>current</code> - component <code>passive</code>. This is essentially the same as scheduling for time=inf.</p> <ul> <li>If the component to be passivated is <code>CURRENT</code>, the component becomes passive, and it will suspend execution internally.</li> <li>If the component to be passivated is <code>passive</code>, the component remains <code>passive</code>.</li> <li>If the component to be passivated is <code>scheduled</code>, the component becomes <code>passive</code>.</li> <li>If the component to be held is <code>standby</code>, the component becomes <code>passive</code>.</li> <li>If the component to be activated is requesting, the request will be terminated, the attribute failed   set and the component becomes passive. It is recommended to use the more versatile activate method.</li> <li>If the component to be activated is waiting, the wait will be   terminated, the attribute failed set and the component becomes passive. It is recommended to   use the more versatile activate method.</li> <li>If the component is interrupted, the component becomes passive.</li> </ul>"},{"location":"component/#cancel","title":"cancel","text":"<p>Cancel has the effect that the component becomes a data component.</p> <ul> <li>If the component to be cancelled is <code>CURRENT</code>, it will suspend execution internally.</li> <li>If the component to be cancelled is <code>passive</code>, scheduled, interrupted  or standby, the component   becomes a data component.</li> <li>If the component to be cancelled is <code>requesting</code>, the request will be terminated, the attribute failed   set, and the component becomes a data component.</li> <li>If the component to be cancelled is waiting, the wait will be terminated, the attribute failed   set and the component becomes a data component.</li> </ul> <p>Examples</p> <ul> <li>Bank Office with Reneging</li> </ul>"},{"location":"component/#standby","title":"standby","text":"<p>Standby has the effect that the component will be triggered on the next simulation event.</p> <ul> <li>If the component is <code>CURRENT</code>, it will suspend execution internally</li> <li>Although theoretically possible, it is not recommended to use standby for non current components. If needed to do so, the pattern to provide the correct receiver is <code>with(nonCurrent){ standby() }</code></li> <li>Not allowed for <code>DATA</code> components or <code>main</code></li> </ul> <p>Examples</p> <ul> <li>Bank Office with Standby</li> </ul>"},{"location":"component/#request","title":"request","text":"<p>Request has the effect that the component will check whether the requested quantity from a resource is available. It is possible to check for multiple availability of a certain quantity from several resources.</p> <p>Instead of checking for all of number of resources, it is also possible to check for any of a number of resources, by setting the <code>oneOf</code> parameter to <code>true</code>.</p> <p>By default, there is no limit on the time to wait for the resource(s) to become available. However, it is possible to set a time with <code>failAt</code> at which the condition has to be met. If that failed, the component becomes <code>CURRENT</code> at the given point of time. This is also known as reneging.</p> <p>If the component is canceled, activated, passivated, interrupted or held the <code>failed</code> flag will be set as well.</p> <ul> <li>If the component is <code>CURRENT</code>, it will suspend execution internally</li> <li>Although theoretically possible it is not recommended to use request for non current components. If needed to do so, the pattern to provide the correct receiver is <code>with(nonCurrent){ request(r) }</code></li> </ul> <p>A component can also actively renege a pending request by calling <code>release(resource)</code>. See <code>Bank3ClerksRenegingResources</code> for an example (as well as <code>Bank3ClerksReneging</code> <code>Bank3ClerksRenegingState</code> for other supported reneging modes).</p>"},{"location":"component/#wait","title":"wait","text":"<p>Wait has the effect that the component will check whether the value of a state meets a given condition. It is possible to check for multiple states. By default, there is no limit on the time to wait for the condition(s) to be met. However, it is possible to set a time with <code>failAt</code> at which the condition has to be met. If that failed, the component becomes <code>CURRENT</code> at the given point of time. The code should then check whether the wait had failed. That can be checked with the <code>Component.failed</code> property.</p> <p>If the component is canceled, activated, passivated, interrupted or held the failed flag will be set as well.</p> <ul> <li>If the component is <code>CURRENT</code>, it will suspend execution internally</li> <li>Although theoretically possible it is not recommended to use wait for non current components. If needed to do so, the pattern to provide the correct receiver is <code>with(nonCurrent){ wait() }</code></li> </ul> <p>Examples</p> <ul> <li>Gas Station</li> </ul> <p>Supported parameters in <code>wait</code></p> <ul> <li><code>state</code> -  A state variable</li> <li><code>waitFor</code> -  The state value to wait for</li> <li><code>description</code> -  The description of the wait request.</li> <li><code>triggerPriority</code> -  The queue priority to be used along with a state change trigger</li> <li><code>failAt</code> -  If the request is not honored before fail_at, the request will be cancelled and the parameter failed will be set. If not specified, the request will not time out.</li> <li><code>failDelay</code> -  If the request is not honored before <code>now + failDelay</code>, the request will be cancelled and the parameter failed will be set. if not specified, the request will not time out.</li> <li><code>failPriority</code> -  Schedule priority of the fail event. If a component has the same time on the event list, this component is sorted according to the priority. An event with a higher priority will be scheduled first.</li> </ul>"},{"location":"component/#interrupt","title":"interrupt","text":"<p>With interrupt components that are not current or data can be temporarily be interrupted. Once a resume is called for the component, the component will continue (for scheduled with the remaining time, for waiting or requesting possibly with the remaining fail_at duration).</p> <p>Examples</p> <ul> <li>Machine Parts</li> </ul>"},{"location":"component/#usage-of-process-interaction-methods-within-a-function-or-method","title":"Usage of process interaction methods within a function or method","text":"<p>There is a way to put process interaction statement in another function or method. This requires a slightly different way than just calling the method.</p> <p>As an example, let's assume that we want a method that holds a component for a number of minutes and that the time unit is actually seconds. So we need a method to wait 60 times the given parameter.</p> <p>We start with a not so elegant solution:</p> <pre><code>object : Component() {\n    override fun process() = sequence&lt;Component&gt;{\n        hold(5.days)\n        hold(5.hours)\n    }\n}\n</code></pre> <p>Now we just add a method <code>holdMinutes</code>. Direct calling <code>holdMinutes</code> is not possible. Instead, we have to define an extension function on <code>SequenceScope&lt;Component&gt;</code>:</p> <pre><code>object : Component() {\n    override fun process() = sequence {\n        holdMinutes()\n        holdMinutes()\n    }\n\n    private suspend fun SequenceScope&lt;Component&gt;.holdMinutes() {\n        hold(5.minutes)\n    }\n}\n</code></pre> <p>All process interaction statements including <code>passivate</code>, <code>request</code> and <code>wait</code> can be used that way!</p> <p>So remember if the method contains a <code>yield</code> statement (technically speaking iss a generator method), it should be called with from an extension function.</p>"},{"location":"component/#component-generator","title":"Component Generator","text":"<p>The creation of components is a key function of most simulations. To facilitate component creation, a <code>ComponentGenerator</code> can be used to create components according to a given inter arrival time (or distribution).</p> <pre><code>ComponentGenerator(iat = exponential(lambda, rg)) {\n    Customer()\n}\n</code></pre> <p>The following arguments are supported when setting up a component generator</p> <ol> <li>Inter arrival duration <code>iat</code> or distribution between history/generations.</li> <li>A builder named <code>builder</code> of type <code>Environment.(counter: Int) -&gt; T</code> allows to specify how the objects of type <code>T</code> are generated. Thereby, <code>counter</code> can be used to name the objects accordingly.</li> </ol> <p>There are also additional arguments available to support more custom/advanced use-cases: </p> <ul> <li><code>startAt</code> - time where the generator starts its operation. If omitted, <code>now</code> is used.</li> <li><code>forceStart</code> - If <code>false</code> (default), the first component will be generated at <code>time = startAt + iat()</code>. If <code>true</code>, the first component will be generated at <code>startAt</code>.</li> <li><code>until</code> - time up to which components should be generated. If omitted, no end.</li> <li><code>total</code> - (maximum) number of components to be generated.</li> <li><code>name</code> - Name of the component.  If the name ends with a period (.), auto serializing will be applied. </li> <li><code>priority</code> - If a component has the same time on the event list, this component is scheduled according to the priority. An event with a higher priority will be scheduled first.</li> <li><code>keepHistory</code> - If <code>true</code>, i will store a reference of all generated components which can be queried with <code>history</code>.</li> <li><code>envProvider</code> - The simulation  context to be used to resolve the <code>org.kalasim.Environment</code></li> </ul> <p>Note, that the entities being created are not required to extend <code>org.kalasim.Component</code>, but can be in fact arbitrary types. </p> <p>Usage:</p> <pre><code>////ComponentGeneratorExamples.kts\nimport org.kalasim.*\nimport kotlin.time.Duration.Companion.days\nimport kotlin.time.Duration.Companion.hours\nimport kotlin.time.Duration.Companion.minutes\n\n\ncreateSimulation {\n\n    // example 1\n    // we can schedule with a probabilist inter-arrival distribution\n    data class Customer(val id: Int)\n\n    ComponentGenerator(uniform(5.minutes, 2.hours)) { customerNo -&gt;\n        Customer(customerNo)\n    }\n\n    // we can also schedule with a fixed rate\n    // here we create 3 strings with fixed inter-arrival duration\n    ComponentGenerator(3.minutes, total = 3) { it }\n\n    // example 2\n    // we define a component with simplistic process definition\n    class Car() : Component() {\n        override fun process() = sequence {\n            hold(3.hours, description = \"driving\")\n        }\n    }\n\n    ComponentGenerator(exponential(3.minutes), until = now + 3.days) {\n        Car() // when creating a component it will be automatically scheduled next\n    }\n\n    // example 3 no-longer recommend:\n    // inter-arrival distribution without duration unit\n    ComponentGenerator(uniform(3, 4).minutes) { Customer(it) }\n}\n</code></pre> <p>More examples</p> <ul> <li>Car Wash</li> <li>Gas Station</li> <li>ATM Queue</li> </ul>"},{"location":"events/","title":"Events","text":"<p>Every simulation includes an internal event bus to provide another way to enable connectivity between simulation components. Components can use <code>log(event)</code> to publish to the event bus from their process definitions.</p> <p>Also, events can be used to study dynamics in a simulation model. We may want to monitor component creation, the event queue, or the interplay between simulation entities, or custom business dependent events of interest. We may  want to trace which process caused an event, or which processes waited for resource. Or a model may require other custom state change events to be monitored. </p>"},{"location":"events/#how-to-create-an-event","title":"How to create an event?","text":"<p>To create a custom event type, we need to subcalss <code>org.kalasim.Event</code>. Events can be published to the internal event bus using <code>log()</code> in process definitions. Here's a simple example</p> <pre><code>import org.kalasim.*\n\nclass MyEvent(val context: String, time: SimTime) : Event(time)\n\ncreateSimulation {\n\n    object : Component(\"Something\") {\n        override fun process() = sequence&lt;Component&gt; {\n            //... a great history\n            log(MyEvent(\"foo\", now))\n            //... a promising future\n        }\n    }\n\n    // register to these events from the environment level\n    addEventListener&lt;MyEvent&gt; { println(it.context) }\n\n    run()\n}\n</code></pre> <p>In this example, we have created custom simulation event type <code>MyEvent</code> which stores some additional context detail about the process. This approach is very common: By using custom event types when building process models with <code>kalasim</code>, state changes can be consumed very selectively for analysis and visualization.</p>"},{"location":"events/#how-to-listen-to-events","title":"How to listen to events?","text":"<p>The event log can be consumed with one more multiple <code>org.kalasim.EventListener</code>s. The classical  publish-subscribe pattern is used here. Consumers can easily route events into arbitrary sinks such as consoles, files, rest-endpoints, and databases, or perform in-place-analytics.</p> <p>We can register a event handlers with <code>addEventListener(org.kalasim.EventListener)</code>. Since an <code>EventListener</code> is modelled as a functional interface, the syntax is very concise and optionally supports generics:</p> <pre><code>createSimulation { \n    // register to all events\n    addEventListener{ it: MyEvent -&gt; println(it)}\n\n    // ... or without the lambda arument just with\n    addEventListener&lt;MyEvent&gt;{  println(it)}\n\n    // register listener only for resource-events\n    addEventListener&lt;ResourceEvent&gt;{ it: ResourceEvent -&gt; println(it)}    \n}\n</code></pre> <p>Event listener implementations typically do not want to consume all events but filter for specific types or simulation entities. This filtering can be implemented in the listener or by providing a the type of interest, when adding the listener.</p>"},{"location":"events/#event-collector","title":"Event Collector","text":"<p>A more selective monitor that will just events of a certain type is the event collector. It needs to be created before running the simulation (or from the moment when events shall be collected).</p> <p><pre><code>class MyEvent(time : SimTime) : Event(time)\n\n// run the sim which create many events including some MyEvents\nenv.run()\n\nval myEvents : List&lt;MyEvent&gt; = collect&lt;MyEvent&gt;()\n\n// or collect with an additional filter condition\nval myFilteredEvents :List&lt;MyEvent&gt; = collect&lt;MyEvent&gt; {\n    it.toString().startsWith(\"Foo\")\n}\n\n// e.g. save them into a csv file with krangl\nmyEvents.asDataFrame().writeCsv(File(\"my_events.csv\"))\n</code></pre> This collector will have a much reduced memory footprint compared to the event log.</p>"},{"location":"events/#event-log","title":"Event Log","text":"<p>Another built-in event listener is the trace collector, which simply records all events and puts them in a list for later analysis.</p> <p>For example to fetch all events in retrospect related to resource requests we could filter by the corresponding event type</p> <pre><code>////EventCollector.kts\nimport org.kalasim.*\nimport org.kalasim.analysis.*\n\ncreateSimulation {\n    enableComponentLogger()\n\n    // enable a global list that will capture all events excluding StateChangedEvent\n    val eventLog = enableEventLog(blackList = listOf(StateChangedEvent::class))\n\n    // run the simulation\n    run(5.seconds)\n\n    eventLog.filter { it is InteractionEvent &amp;&amp; it.component?.name == \"foo\" }\n\n    val claims = eventLog //\n        .filterIsInstance&lt;ResourceEvent&gt;()\n        .filter { it.type == ResourceEventType.CLAIMED }\n}\n</code></pre>"},{"location":"events/#asynchronous-event-consumption","title":"Asynchronous Event Consumption","text":"<p>Sometimes, events can not be consumed in the simulation thread, but must be processed asynchronously. To do so we could use a custom thread or we could setup a coroutines channel for log events to be consumed asynchronously. These technicalities are already internalized in <code>addAsyncEventLister</code> which can be parameterized with a custom coroutine scope if needed. So to consume, events asynchronously, we can do:</p> <pre><code>////LogChannelConsumerDsl.kt\nimport org.kalasim.*\nimport org.kalasim.analysis.InteractionEvent\n\ncreateSimulation {\n    ComponentGenerator(iat = constant(1).days) { Component(\"Car.${it}\") }\n\n    // add custom log consumer\n    addAsyncEventListener&lt;InteractionEvent&gt; { event -&gt;\n        if(event.current?.name == \"ComponentGenerator.1\")\n            println(event)\n    }\n\n    // run the simulation\n    run(10.weeks)\n}\n</code></pre> <p>In the example, we can think of a channel as a pipe between two coroutines. For details see the great article Kotlin: Diving in to Coroutines and Channels.</p>"},{"location":"events/#internal-events","title":"Internal Events","text":"<p><code>kalasim</code> is using the event-bus extensively to publish a rich set of built-int events.</p> <ul> <li>Interactions via <code>InteractionEvent</code></li> <li>Entity creation via <code>EntityCreatedEvent</code> </li> <li>Resource requests, see resource events.</li> </ul> <p></p> <p>To speed up simulations, internal events can be disabled.</p>"},{"location":"events/#component-logger","title":"Component Logger","text":"<p>For internal interaction events, the library provides a  built-in textual logger. With component logging being enabled, <code>kalasim</code> will print a tabular listing of component state changes and interactions. Example:</p> <pre><code>time      current component        component                action      info                          \n--------- ------------------------ ------------------------ ----------- -----------------------------\n.00                                main                     DATA        create\n.00       main\n.00                                Car.1                    DATA        create\n.00                                Car.1                    DATA        activate\n.00                                main                     CURRENT     run +5.0\n.00       Car.1\n.00                                Car.1                    CURRENT     hold +1.0\n1.00                               Car.1                    CURRENT\n1.00                               Car.1                    DATA        ended\n5.00      main\nProcess finished with exit code 0\n</code></pre> <p>Console logging is not active by default as it would considerably slow down larger simulations. It can be enabled when creating a simulation.</p> <pre><code>createSimuation(enableComponentLogger = true){\n    // some great sim in here!!\n}\n</code></pre> <p>Note</p> <p>The user can change the width of individual columns with <code>ConsoleTraceLogger.setColumnWidth()</code></p>"},{"location":"events/#bus-metrics","title":"Bus Metrics","text":"<p>By creating a <code>BusMetrics</code> within a simulation environment, log statistics (load &amp; distribution) are computed and logged to the bus.</p> <p><pre><code>createSimulation{\n    BusMetrics(\n        timelineInterval = 3.seconds,\n        walltimeInterval =  20.seconds\n    )    \n}\n</code></pre> Here, every 3 seconds in simulation time, the event rate is logged. Additionally, every 20 walltime second, the event rate is logged asynchronously.</p> <p>Metrics are logged via <code>slf4j</code>. The async logging can be stopped via <code>busMetrics.stop()</code>.</p>"},{"location":"events/#logging-framework-support","title":"Logging Framework Support","text":"<p><code>kalasim</code> is using <code>slf4j</code> as logging abstraction layer. So, it's very easy to also log <code>kalasim</code> events via another logging library such as log4j, https://logging.apache.org/log4j/2.x/, kotlin-logging or the jdk-bundled util-logger. This is how it works:</p> <pre><code>////LoggingAdapter.kts\nimport org.kalasim.examples.er.EmergencyRoom\nimport java.util.logging.Logger\nimport kotlin.time.Duration.Companion.days\n\n// Create a simulation of an emergency room\nval er = EmergencyRoom()\n\n// Add a custom event handler to forward events to the used logging library\ner.addEventListener { event -&gt;\n    // resolve the event type to a dedicated logger to allow fine-grained control\n    val logger = Logger.getLogger(event::class.java.name)\n\n    logger.info { event.toString() }\n}\n\n// Run the model for 100 days\ner.run(100.days)\n</code></pre> <p>For an in-depth logging framework support discussion see #40.</p>"},{"location":"events/#tabular-interface","title":"Tabular Interface","text":"<p>A typesafe data-structure is usually the preferred for modelling. However, accessing data in a tabular format can also be helpful to enable statistical analyses. Enabled by krangl's <code>Iterable&lt;T&gt;.asDataFrame()</code> extension, we can  transform  records, events and simulation entities easily into tables. This also provides a semantic compatibility layer with other DES engines (such as simmer), that are centered around tables for model analysis.</p> <p>We can apply such a transformation simulation <code>Event</code>s. For example, we can apply an instance filter to the recorded log to extract only log records relating to resource requests. These can be transformed and converted to a csv with just:</p> <pre><code>// ... add your simulation here ...\ndata class RequestRecord(val requester: String, val timestamp: Double, \n            val resource: String, val quantity: Double)\n\nval tc = sim.get&lt;TraceCollector&gt;()\nval requests = tc.filterIsInstance&lt;ResourceEvent&gt;().map {\n    val amountDirected = (if(it.type == ResourceEventType.RELEASED) -1 else 1) * it.amount\n    RequestRecord(it.requester.name, it.time, it.resource.name, amountDirected)\n}\n\n// transform data into data-frame (for visualization and stats)  \nrequests.asDataFrame().writeCSV(\"requests.csv\")\n</code></pre> <p>The transformation step is optional, <code>List&lt;Event&gt;</code> can be transformed <code>asDataFrame()</code> directly.</p>"},{"location":"events/#events-in-jupyter","title":"Events in Jupyter","text":"<p>When working with jupyter, we can harvest the kernel's built-in rendering capabilities to render events. Note that we need to filter for specific event type to capture all attributes.</p> <p></p> <p>For a fully worked out example see one of the example notebooks .</p>"},{"location":"examples/","title":"Overview","text":"<p>There's nothing more intriguing than a good example. To provide guidance we tried to categorize our examples by difficulty. Categorization is opinionated and just tries to pave an entry path into <code>kalasim</code> API.</p> <p>Simple</p> <ul> <li>Car - A single car, a driver, and red traffic light in the middle of the night. The thrilling landing page example but this time fully documented with an extensive code-walkthrough.  </li> <li>Traffic - Car navigate through a simple traffic model with crossings and traffic-lights. Clearly, they need to refill, but there is just a limited number of slots as the gas station.</li> <li>Bank Office with 1 clerk - A classic queue, where customers arrive at a bank and need to be serviced</li> <li>Bridge Game - A survival analysis of murderous game in Netflix' famous Squid Games series. </li> </ul> <p>Moderate</p> <ul> <li>Movie Theater - A big cinema, great movies. How long does it take before tickets are sold out?</li> <li>Car Wash - A car wash with limited throughput, and a continuous stream of new customers</li> <li>Machine Parts - A small shop-floor with multi-part machines, where all parts must be functional to avoid tool downtime</li> <li>Machine Shop - A day in a life of a busy maintenance engineer. Tools break and need to be repaired before they can continue operation</li> <li>The Ferryman - A wild river, one boat only, and a patient ferryman transporting batches of passengers across the body of water</li> </ul> <p>Elaborate</p> <ul> <li>ATM - The canonical queue model. Here, illustrated with a cash machine that needs to serve customers.</li> <li>Gas Station - A gas-station again, but this time the focus is on the station itself and how it struggls to get new petrol to serve hungry customers.</li> <li>Bank Office - A classical queue problem where customers need to be served. Here solved 4 times in different ways using different <code>kalasim</code> models.</li> <li>Dining Philosophers -  Philosophers sit at a round table with bowls of spaghetti and try to eat. It ain't easy...</li> <li>Office Tower - A busy office building, where workers need to get from floor to floor using a limited number of elevators.</li> <li>Call Center - A support center sizing analysis to figure the correct number of support technicians before failing the business in real life.</li> </ul>"},{"location":"faq/","title":"F.A.Q.","text":""},{"location":"faq/#why-rebuilding-salabim","title":"Why rebuilding <code>salabim</code>?","text":"<p>Great question! Initial development was driven by curiosity about the <code>salabim</code> internals. Also, it lacked (arguably) a modern API touch which made some of our use cases more tricky to implement.</p> <p><code>kalasim</code> implements all major features of <code>salabim</code> as documented under https://www.salabim.org/manual/.</p>"},{"location":"faq/#what-tf-is-the-meaning-of-kalasim","title":"What (TF) is the meaning of <code>kalasim</code>?","text":"<p>We went through multiple iterations to come up with this great name:</p> <ol> <li><code>desimuk</code> - {d}iscrete {e}vent {simu}lation with {k}otlin seemed a very natural and great fit. Unfortunately, Google seemed more convinced  - for reasons that were outside the scope of this project - that this name related mostly with indian porn.</li> <li><code>desim</code> - seemed fine initially, until we discovered another simulation engine https://github.com/aybabtme/desim with the same name.</li> <li><code>kalasim</code>  honors its origin by being somewhat phonetically similar to <code>salabim</code> while stressing Kotlin with the <code>k</code>, and the simulation scope with the <code>sim</code> instead of the <code>bim</code>.</li> </ol> <p>In case you also wonder why <code>salabim</code> was named <code>salabim</code>, see here.</p>"},{"location":"faq/#can-we-use-it-with-from-java","title":"Can we use it with from Java?","text":"<p>Kotlin-2-Java interop is a core design goal of Kotlin. Thus, kalasim should work without any issues from java. However, we have not tried yet, so in case you struggle please file a ticket.</p>"},{"location":"faq/#why-can-we-use-resourcerequest1","title":"Why can we use resource.request(1)?","text":"<p>Admittedly, the provided resource request syntax <code>request(resource)</code> feels a bit dated. It's designed in that way because we would need multiple receiver support for extensions functions to provide a more object-oriented API. However, extensions with multiple receivers are not (yet) supported by Kotlin.</p>"},{"location":"faq/#how-to-fix-simulation-environment-context-is-missing-error","title":"How to fix <code>Simulation environment context is missing</code> error?","text":"<p>You would need to create a simulation context before instantiating the resources, components or states. E.g. with</p> <pre><code>Environment().apply{\n    val devices = Resource(name = \"devices\", capacity = 3)\n}\n</code></pre> <p>For more details regarding koin and dependency injection see https://www.kalasim.org/basics/#dependency-injection</p>"},{"location":"getting_started/","title":"How to get started with <code>kalasim</code>?","text":"<p>Depending on your prior experience with simulation and programming,  it may take time to become fluent with <code>kalasim</code>.</p> <p>To streamline the learning experience, we've organized our learning process suggestions by audience.</p>"},{"location":"getting_started/#i-have-experience-with-simulation","title":"I have experience with simulation","text":"<ol> <li>Start by doing a crash course to learn some kotlin programming basics </li> <li>Run the provided simulation examples Simple Traffic and Extended Traffic in your browser (powered by datalore)</li> <li>Pick your favorite example and try converting it into a datalore notebook</li> <li>Try visualizing some metrics using the built-in visualization methods</li> </ol>"},{"location":"getting_started/#i-have-experience-with-programming","title":"I have experience with programming","text":"<ol> <li>Download the community edition of Intellij IDEA</li> <li>Follow the instructions to create a Kotlin application</li> <li>Add <code>kalasim</code> as a dependency as described in the setup</li> <li>Understand the fundamentals of simulation and the main simulation entities</li> <li>Pick you favorite example and work it out towards your own interest/use-cases</li> </ol>"},{"location":"getting_started/#get-in-touch","title":"Get in touch","text":"<p>Feel welcome to get in touch with us for support, consulting and discussion.</p>"},{"location":"monitors/","title":"Monitors","text":"<p>Monitors are a built-in mechanism of <code>kalasim</code> to collect data from a simulation. Monitors collect metrics automatically for resources, components, states and collections. On top of that the user can define her own monitors.</p> <p>Monitors allow to capture  and visualize the dynamics of a simulation model. There are two types of monitors:</p> <ul> <li>Level monitors are useful to collect data about a variable that keeps its value over a certain length   of time, such as the length of a queue or the color of a traffic light.</li> <li>Value monitors are useful to collect distributional statistics without a time-dimension. Examples, are the length of stay in a queue, or the number of processing steps of a part.</li> </ul> <p>For both types, the time is always collected, along with the value.</p> <p>Monitors support a wide range of statistical properties via <code>m.statistics()</code> including</p> <ul> <li>mean</li> <li>median</li> <li>percentiles</li> <li>min and max</li> <li>standard deviation</li> <li>histograms</li> </ul> <p>For all these statistics, it is possible to exclude zero entries, e.g. <code>m.statistics(statistics=true)</code> returns the mean, excluding zero entries.</p> <p>Monitors can be disabled with <code>disable()</code> by setting the boolean flag ``.</p> <pre><code>m.disable()  // disable monitoring\n\nm.reset()              // reenable statistics monitoring\nm.reset(initialValue)   // reenable level monitoring\n</code></pre> <p>Continuation of a temporarily disabled monitor is currently not supported.</p>"},{"location":"monitors/#value-monitors","title":"Value Monitors","text":"<p>Non-level monitors collects values which do not reflect a level, e.g. the processing time of a part.</p> <p>There are  2 implementations to support categorical and numerical attributes</p> <ul> <li><code>org.kalasim.NumericStatisticMonitor</code></li> <li><code>org.kalasim.FrequencyMonitor</code></li> </ul> <p>Besides, it is possible to get all collected values as list with <code>m.statistics().values</code>.</p> <p>Calling <code>m.reset()</code> will clear all collected values.</p>"},{"location":"monitors/#level-monitors","title":"Level Monitors","text":"<p>Level monitors tally levels along with the current (simulation) time. E.g. the number of parts a machine is working on.</p> <p>There are  2 implementations to support categorical and numerical attributes</p> <ul> <li><code>org.kalasim.CategoryTimeline</code></li> <li><code>org.kalasim.MetricTimeline</code></li> </ul> <p>Level monitors allow to query the value at a specific time <pre><code>val nlm = MetricTimeline()\n// ... collecting some data ...\nnlm[4]  // will query the value at time 4\n\nnlm[now] // will query the current value \n</code></pre></p> <p>In addition to standard statistics, level monitors support the following statistics</p> <ul> <li><code>duration</code></li> </ul> <p>For all statistics, it is possible to exclude zero entries, e.g. <code>m.statistics(excludeZeros=true).mean</code> returns the mean, excluding zero entries.</p> <p>Calling <code>m.reset()</code> will clear all tallied values and timestamps.</p> <p>The statistics of a level monitor can be printed with <code>m.printStatistics()</code>.</p>"},{"location":"monitors/#histograms","title":"Histograms","text":"<p>The statistics of a monitor can be printed with <code>printStatistics()</code>. E.g: <code>waitingLine.lengthOfStayMonitor.printStatistics()</code>:</p> <pre><code>{\n    \"all\": {\n      \"entries\": 5,\n      \"ninety_pct_quantile\": 4.142020545932034,\n      \"median\": 1.836,\n      \"mean\": 1.211,\n      \"ninetyfive_pct_quantile\": 4.142020545932034,\n      \"standard_deviation\": 1.836\n    },\n    \"excl_zeros\": {\n      \"entries\": 2,\n      \"ninety_pct_quantile\": 4.142020545932034,\n      \"median\": 1.576,\n      \"mean\": 3.027,\n      \"ninetyfive_pct_quantile\": 4.142020545932034,\n      \"standard_deviation\": 1.576\n    }\n}\n</code></pre> <p>And, a histogram can be printed with <code>printHistogram()</code>. E.g. <code>waitingLine.lengthOfStayMonitor.printHistogram()</code>:</p> <pre><code>Histogram of: 'Available quantity of fuel_pump'\n              bin | entries |  pct |                                         \n[146.45, 151.81]  |       1 |  .33 | *************                           \n[151.81, 157.16]  |       0 |  .00 |                                         \n[157.16, 162.52]  |       0 |  .00 |                                         \n[162.52, 167.87]  |       0 |  .00 |                                         \n[167.87, 173.23]  |       1 |  .33 | *************                           \n[173.23, 178.58]  |       0 |  .00 |                                         \n[178.58, 183.94]  |       0 |  .00 |                                         \n[183.94, 189.29]  |       0 |  .00 |                                         \n[189.29, 194.65]  |       0 |  .00 |                                         \n[194.65, 200.00]  |       1 |  .33 | *************    \n</code></pre> <p>If neither <code>binCount</code>, nor <code>lowerBound</code> nor <code>upperBound</code> are specified, the histogram will be autoscaled.</p> <p>Histograms can be printed with their values, instead of bins. This is particularly useful for non numeric tallied values, such as names::</p> <pre><code>val m = FrequencyMonitor&lt;Car&gt;()\n\nm.addValue(AUDI)\nm.addValue(AUDI)\nm.addValue(VW)\nrepeat(4) { m. addValue(PORSCHE)}\n\nm.printHistogram()\n</code></pre> <p>The output of this:</p> <pre><code>Summary of: 'FrequencyMonitor.2'\n# Records: 7\n# Levels: 3\n\nHistogram of: 'FrequencyMonitor.2'\n              bin | entries |  pct |                                         \nAUDI              |       2 |  .29 | ***********                             \nVW                |       1 |  .14 | ******                                  \nPORSCHE           |       4 |  .57 | ***********************           \n</code></pre> <p>It is also possible to specify the values to be shown:</p> <pre><code>m.printHistogram(values = listOf(AUDI, TOYOTA)) \n</code></pre> <p>This results in a further aggregated histogram view where non-selected values are agregated and listes values are forced in the display even if they were not observed.</p> <pre><code>Summary of: 'FrequencyMonitor.1'\n# Records: 7\n# Levels: 3\n\nHistogram of: 'FrequencyMonitor.1'\n              bin | entries |  pct |                                         \nAUDI              |       2 |  .29 | ***********                             \nTOYOTA            |       0 |  .00 |                                         \nrest              |       5 |  .71 | *****************************\n</code></pre> <p>It is also possible to sort the histogram on the weight (or number of entries) of the value:</p> <pre><code>m.printHistogram(sortByWeight = true)\n</code></pre> <p>The output of this:</p> <pre><code>Summary of: 'FrequencyMonitor.1'\n# Records: 7\n# Levels: 3\n\nHistogram of: 'FrequencyMonitor.1'\n              bin | entries |  pct |                                         \nPORSCHE           |       4 |  .57 | ***********************                 \nAUDI              |       2 |  .29 | ***********                             \nVW                |       1 |  .14 | ******\n</code></pre> <p>For numeric monitors it is possible to show values instead of ranges as bins <pre><code>val nlm = MetricTimeline()\n\nnow += 2\nnlm.addValue(2)\n\nnow += 2\nnlm.addValue(6)\nnow += 4\n\nnlm.printHistogram(valueBins = false)\nnlm.printHistogram(valueBins = true)\n</code></pre></p> <p>which will result by default in</p> <p><pre><code>Histogram of: 'MetricTimeline.1'\n              bin | entries |  pct |                                         \n[.00, .60]        |     232 |  .23 | *********                               \n[.60, 1.20]       |       0 |  .00 |                                         \n[1.20, 1.80]      |       0 |  .00 |                                         \n[1.80, 2.40]      |     233 |  .23 | *********                               \n[2.40, 3.00]      |       0 |  .00 |                                         \n[3.00, 3.60]      |       0 |  .00 |                                         \n[3.60, 4.20]      |       0 |  .00 |                                         \n[4.20, 4.80]      |       0 |  .00 |                                         \n[4.80, 5.40]      |       0 |  .00 |                                         \n[5.40, 6.00]      |     535 |  .54 | *********************                   \n</code></pre> However, when valueBins is enabled the histogram becomes</p> <pre><code>Histogram of: 'MetricTimeline.1'\n              bin | entries |  pct |                                         \n0.0               |       2 |  .25 | **********                              \n2.0               |       2 |  .25 | **********                              \n6.0               |       4 |  .50 | ********************\n</code></pre>"},{"location":"monitors/#monitors-arithmetics","title":"Monitors Arithmetics","text":"<p>It is possible to merge the metric timeline monitors</p> <pre><code>val mtA = MetricTimeline()\nval mtB = MetricTimeline()\n\n// we can do all types of arithmetics\nmtA + mtB\nmtA - mtB\nmtA / mtB\nmtA * mtB\n\n// or work out their average over time\nlistOf(mtA, mtB).mean()\n</code></pre> <p>It is also possible to merge the resulting statistics of multiple monitors</p> <pre><code>val flmA = CategoryTimeline(1)\nval flmB = CategoryTimeline(2)\n\n// ... run simulation \n\nval mergedStats: EnumeratedDistribution&lt;Int&gt; = listOf(flmA, flmB).mergeStats()\n</code></pre> <p>See <code>MergeMonitorTests</code> for more examples regarding the other monitor types.</p>"},{"location":"monitors/#slicing-of-monitors","title":"Slicing of monitors","text":"<p>Slicing of monitors is supported for <code>CategoryTimeline</code></p> <pre><code>val ct = CategoryTimeline(\"foo\")\n\n// compute frequency table for range\nct.summed(now-3.hours, now.hours)\n\n// same but output EnumeratedDistribution\nval dist: EnumeratedDistribution&lt;String&gt; = ct.valueDistribution(now-3.hours, now.hours)\n</code></pre> <p>Use-cases for slicing are</p> <ul> <li>to get statistics on a monitor with respect to a given time period, most likely a subrun</li> <li>to get statistics on a monitor with respect to a recurring time period, like hour 0-1, hour 0-2, etc.</li> </ul>"},{"location":"monitors/#summarizing-a-monitor","title":"Summarizing a monitor","text":"<p><code>Monitor.statistics()</code>  returns a 'frozen' monitor that can be used to store the results not depending on the current environment. This is particularly useful for persisting monitor statistics for later analysis.</p>"},{"location":"monitors/#visualization","title":"Visualization","text":"<p>It is possible to render monitors with the following extension functions <pre><code>NumericStatisticMonitor.display() \nMetricTimeline.display()\n</code></pre></p> <p></p> <p>In particular multiple outputs are supported here by the underlying <code>kravis</code> visualization windows, which allows forward backward navigation (via the arrow buttons). See <code>org.kalasim.examples.bank.resources.Bank3ClerksResources</code> for an example where multiple visualizing are combined to inspect the internal state of the simulation.</p> <p>Note that, currently monitor visualization just works in retrospect, and it is not (yet) possible to view the progression while a simulation is still running.</p>"},{"location":"resource/","title":"Resources","text":"<p>Resources are a powerful way of process interaction. Next to process definitions, resources are usually the most important elements of a simulation. Resources allow modeling rate-limits which are omnipresent in every business process.</p> <p>A resource has always a capacity (which can be zero and even negative). This capacity will be specified at time of creation, but can be changed later with <code>r.capacity = newCapacity</code>. Note that this may lead to requesting components to be honored if possible.</p> <p>There are two of types resources:</p> <ul> <li>Claimable resources, where each claim is associated with a component (the claimer). It is not necessary that the claimed quantities are integer.</li> <li>Depletable resources, where only the claimed quantity is registered. This is most useful for dealing with levels, lengths, etc.</li> </ul>"},{"location":"resource/#claimable-resources","title":"Claimable Resources","text":"<p>Claimable resources are declared with:</p> <pre><code>val clerks = Resource(\"clerks\", capacity = 3)\n</code></pre> <p>Claimable resources have several attributes to query their status</p> <p><pre><code>clerks.claimed // currently claimed quantity\nclerks.available // currently available quantity\n\nclerks.capacity // current capacity\n\nclerks.occupancy // calculated by claimedQuantity / capacity\n\nclerks.requesters  // components currently requesting it \nclerks.claimers // components currently claiming it \n</code></pre> All these attributes are read-only, except for the capacity of the resource, which can be adjusted dynamically</p> <pre><code>clerks.capacity  = 3 // set capacity to 3\n</code></pre> <p>Any component can <code>request</code> from a resource in its process method. The user must not use <code>request</code> outside of a component's process definition.</p> <p><code>request</code> has the effect that the component will check whether the requested quantity from a resource is available. It is possible to check for multiple availability of a certain quantity from several resources.</p> <p>Claimable resources have a queue called <code>requesters</code> containing all components trying to claim from the resource. In addition, there is a list <code>claimers</code> containing all components claiming from the resource. Both queues can not be modified but are very useful for analysis.</p> <p>Notes</p> <ul> <li><code>request</code> is not allowed for data components or main.</li> <li>If to be used for the current component (which will be nearly always the case), use <code>yield (request(...))</code>.</li> <li>If the same resource is specified more that once, the quantities are summed.</li> <li>The requested quantity may exceed the current capacity of a resource.</li> <li>The parameter <code>failed</code> will be reset by a calling <code>request</code> or <code>wait</code>.</li> </ul> <p>Some Examples</p> <ul> <li>Bank Office with Resources</li> <li>Car Wash</li> <li>Traffic</li> <li>Gas Station</li> </ul>"},{"location":"resource/#depletable-resources","title":"Depletable Resources","text":"<p>For depletable (which are also sometimes referred to as anonymous) resources, it may be not allowed to exceed the capacity and have a component wait for enough (claimed) capacity to be available. That may be accomplished by using a negative quantity in the <code>Component.request()</code> call. However, to clarify the semantics of resource depletion, the API includes a dedicated <code>DepletableResource</code>.</p> <ul> <li>A depletable resource can be consumed with <code>Component.take()</code>.</li> <li>A depletable resource can refilled/recharged with <code>Component.put()</code>.</li> </ul> <p>Info</p> <p>Both <code>put()</code> and <code>take</code> are just typesafe wrappers around <code>request()</code>. With <code>put()</code> quantities of resources are negated before calling <code>Component.request()</code> internally.</p> <p>To create a depletable resource we do</p> <pre><code>val tank = DepletableResource(capacity = 10, initialLevel = 3)\n</code></pre> <p>We can declare its maximum capacity and its initial fill level. The latter is optional and defaults to the capacity of the resource.</p> <p>In addition to the <code>Resource</code> attributes, depletable resources have the following attributes to streamline model building</p> <ul> <li><code>level</code> - Indicates the current level of the resource</li> <li><code>isDepleted</code> - Indicates if depletable resource is depleted (level==0)</li> <li><code>isFull</code> - Indicates if depletable resource is at full capacity</li> </ul> <p>The model below illustrates the use of <code>take</code> and <code>put</code>. See the Gas Station simulation for a living example.</p> <p>Examples using depletable resources * Shipyard * Lunar Mining which models deposits as depletable resource * Gas Station where the central fuel storage is modeled as depletable resource</p>"},{"location":"resource/#request-scope","title":"Request Scope","text":"<p>The recommended <code>request</code> usage pattern for resources is the request scope which</p> <ol> <li>requests a resource,</li> <li>executes some action,</li> <li>and finally releases the claimed resources.</li> </ol> <pre><code>request(clerks) { //1\n    hold(1, description = \"doing something\") //2\n} //3\n</code></pre> <p>In the example, <code>kalasim</code> will release the clerks automatically at the end of the request scope.</p> <p>When requesting from a single resource in a nested way, claims are merged.</p>"},{"location":"resource/#unscoped-usage","title":"Unscoped Usage","text":"<p>The user can omit the request scope (not recommended and mostly not needed), and release claimed resources with <code>release()</code>.</p> <pre><code>request(clerks)\n\nhold(1, description = \"doing something\")\n\nrelease(clerks) \n</code></pre> <p>Typically, this is only needed when releasing a defined quantity (other than the default quantity <code>1</code>) from a resource with <code>c.release()</code>, e.g.</p> <pre><code>customer.release(clerks)  // releases all claimed quantity from r\ncustomer.release(clerks, 2)  // release quantity 2 from r\n</code></pre> <p>After a release, all other requesting components will be checked whether their claims can be honored.</p>"},{"location":"resource/#quantity","title":"Quantity","text":"<p>Some requests may request more than 1 unit from a resource. The number of requested resource units is called request quantity. Quantities are strictly positive, and kalasim also supports non-integer quantities. To request more than one unit from a resource, the user can use the follow API:</p> <pre><code>// request 1 from clerks \nrequest(clerks)\n\n// request 2 elements from clerks\nrequest(clerks, quantity = 2)\n\n// also, an infix version is supported\nrequest(clerks withQuantity 2)\n\n\n// request can be decimals\nrequest(clerks, quantity = 1.234)\n\n// quantities must be positive. This will FAIL with an error\nrequest(clerks, quantity = -3) // will throw exception!\n</code></pre>"},{"location":"resource/#request-honor-policies","title":"Request Honor Policies","text":"<p>When requesting, it may (and will) happen that a resource is currently fully claimed, and the request can not be honored right away. Requests may even queue up, if a resource is under more demand than it can serve. To resolve competing requests in an orderly fashion, kalasim supports different honor policies. An honor policy defines the order in which competing requests are honored.</p> <p>Honor policies are applied to both claimable and also depletable resources.</p> <p>Policy implementations extend <code>org.kalasim.RequestHonorPolicy</code>.The following policies are supported:</p> <ul> <li>Strict first come, first serve (<code>StrictFCFS</code>, default). This policy will honor request in order of appearance. So, it actually will wait to honor \"big\" requests, even if smaller requests that could be honored already are queueing up already. This is the default policy in kalasim, as we assume this being the most intuitive behavior in most situations.</li> <li>Relaxed first come, first serve (<code>RelaxedFCFS</code>): This policy will honor claimable requests first. It will honor small requests even if larger requests are already waiting longer in line. FCFS is used as secondary order scheme in situations where multiple concurrent requests of the same quantity are waiting in line.</li> <li>Smallest Quantity First (<code>SQF</code>) This policy tries to maximize \"customer\" throughput. Also this policy will fall back to an FCFS to resolve ambiguities. It will maximize the total number of requests being honored, whereas large requests may need to wait for a long time. For depletable resources, just imagine a resource that is constantly low on supply. When new supply becomes available, the resource could serve as many requesters as possible. Also, for regular resources this concept applies, e.g. in customer support, where customers require one or multiple mechanics, and the company decides to serve the least staffing-intense requests first.</li> <li>Weighted FCFS (<code>WeightedFCSC</code>): Here the user can supply a weight <code>\u03b1</code> that is used to compute an ordering based on <code>\u03b1 * time_since_insert / quantity</code>. This will progressively weigh the time since the request against request quantity. The policy will prefer smaller requests, but will ensure that also larger request are finally be honored.</li> <li>Random Order (<code>RandomOrder</code>): This honor policy will honor requests in a random order. Sometimes real world processes lack a structured policy to resolve concurrent demand, so it may help understanding the current situation, before working out a better planning strategy.</li> </ul> <p>As of now, the user can not provide custom <code>RequestHonorPolicy</code> implementations. To realize more sophisticated resource request regimes, she must implement their business specific request mechanism separately.</p> <p>Important</p> <p>Priorities always take precedence over the honor policy set for a resource. If a user sets a request priority, it will be respected first. That is, it does always try honoring by priority first, and only once all requests at the highest priority level are honored, it will climb down the ladder. Within a priority-level the selected honor policy is applied.</p> <p>Note</p> <p>A SQF policy could also be realized by using the negated quantity as request priority. However, for sake of clarity is recommended to use priorities to actually reflect business/domain needs, and use the provided SQL as baseline policy.</p>"},{"location":"resource/#request-priority","title":"Request Priority","text":"<p>As multiple components may request the same resource, it is important to prioritize requests. This is possible by providing a request priority</p> <pre><code>request(clerks, priority = IMPORTANT)\n\n// or equivalently using the dsl-request-builder syntax\nrequest(clerks withPriority IMPORTANT) \n</code></pre> <p>Irrespective of the used honor policy, kalasim will always honor requests on a resource sorted by priority.</p> <p>There are different predefined priorities which correspond to the following sort-levels</p> <ul> <li><code>LOWEST</code> (-20)</li> <li><code>LOW</code> (-10)</li> <li><code>NORMAL</code> (0, Default)</li> <li><code>IMPORTANT</code> (10)</li> <li><code>CRITICAL</code> (20)</li> </ul> <p>The user can also create more fine-grained priorities with <code>Priority(23)</code></p>"},{"location":"resource/#capacity-limit-modes","title":"Capacity Limit Modes","text":"<p>It may happen that <code>request()</code> (regular resources), <code>take()</code> or <code>put()</code> (depletable resources) would fail because the request quantity exceeds a resource's <code>capacity</code>. A <code>CapacityLimitMode</code> can be configured to handle such situations gracefully:</p> <ol> <li><code>FAIL</code>- Fail with a <code>CapacityLimitException</code> if request size exceeds resource capacity. (Default)</li> <li><code>SCHEDULE</code> - Schedule request even the current <code>capacity</code> won't ever honor the request, hoping for a later capacity increase.</li> <li><code>CAP</code> - Depletable resources also support capping <code>put</code> requests at capacity level</li> </ol>"},{"location":"resource/#multiple-resources","title":"Multiple resources","text":"<p>It is also possible to request for more resources at once. To enable this functionality in a typed manner, we provide a small builder API containing  <code>withPriority</code>, <code>withQuantity</code>, and <code>andPriority</code>. In the following examples, we request 1 quantity from <code>clerks</code> AND 2 quantities from <code>assistance</code>.</p> <pre><code>request(\n    fireBrigade withQuantity 10,\n    ambulance withPriority IMPORTANT,\n    police withQuantity 3 andPriority IMPORTANT\n) \n</code></pre> <p>Another method to query from a pool of resources are group requests. These are simply achieved by grouping resources in a <code>List</code> before requesting from it using <code>oneOf=true</code>.</p> <pre><code>//// ResourceGroups.kts\nimport org.kalasim.Component\nimport org.kalasim.Resource\nimport kotlin.time.Duration.Companion.minutes\n\nval drMeier = Resource()\nval drSchreier = Resource()\n\nval doctors: List&lt;Resource&gt; = listOf(drMeier, drSchreier)\n\nobject : Component() {\n    override fun process() = sequence {\n        request(doctors, oneOf = true) {\n            hold(5.minutes, \"first aid\")\n        }\n\n        // the patient needs brain surgery, only Dr Meier can do that\n        request(drMeier) {\n            hold(10.minutes, \"brain surgery\")\n        }\n    }\n}\n</code></pre> <p>Typical use cases are staff models, where certain colleagues have similar but not identical qualification. In case of the same qualification, a single resource with a <code>capacity</code> equal to the staff size, would be usually the better/correct solution.</p>"},{"location":"resource/#resource-selection","title":"Resource Selection","text":"<p>To request alternative resources, the user can set the parameter <code>request(r1, r2 withQuantity 3, oneOf=true)</code>, which will would result in requesting 1 quantity from <code>r1</code> OR 3 quantities from <code>r2</code>. With <code>oneOf=true</code>, we express to the simulation engine, that fulfilling one claim only is sufficient.</p> <p>To also enable more controlled resource selection scenarios, there is a special mechanism to select resources dynamically. With <code>selectResource()</code> a resource can be selected from a list of resources using a policy. There are several policies provided via <code>ResourceSelectionPolicy</code>:</p> <ul> <li><code>ShortestQueue</code>: The resource with the shortest queue, i.e. the least busy resource is selected.</li> <li><code>RoundRobin</code>: Resources will be selected in a cyclical order.</li> <li><code>FirstAvailable</code>: The first available resource is selected.</li> <li><code>RandomAvailable</code>: An available resource is randomly selected.</li> <li><code>Random</code>: A resource is randomly selected.</li> </ul> <p>The <code>RandomAvailable</code> and <code>FirstAvailable</code> policies check for resource availability i.e. whether the current capacity is sufficient to honor the requested quantity (defaulting to <code>1</code>). Resources that do not meet this requirement will not be considered for selection. When using these policies, an error will be raised if all resources are unavailable.</p> <p>Warning</p> <p>With <code>selectResource</code>, a resource will be only selected. It won't actually request it.</p> <p>Example</p> <pre><code>////ResourceSelection.kts\nimport org.kalasim.*\nimport org.kalasim.ResourceSelectionPolicy.ShortestQueue\n\ncreateSimulation {\n    enableComponentLogger()\n\n    val doctors = List(3) { Resource() }\n\n    class Patient : Component() {\n        override fun process() = sequence {\n            val requiredQuantity = 3\n\n            val selected = selectResource(\n                doctors,\n                quantity = requiredQuantity,\n                policy = ShortestQueue\n            )\n\n            request(selected withQuantity requiredQuantity) {\n                hold(10)\n            }\n        }\n    }\n\n    ComponentGenerator(exponential(1).minutes) { Patient() }\n    run(100)\n}\n</code></pre> <p>An alternative more direct approach to achieve round-robin resource selection (e.g. for nested calls) could also be implemented (example) with an iterator.</p>"},{"location":"resource/#events","title":"Events","text":"<p>Resources will log all changes with 2 event types</p>"},{"location":"resource/#resource-event","title":"Resource Event","text":"<p>Events of type <code>org.kalasim.ResourceEvent</code> will indicate changes as they occur. The following fields are included in each event</p> <ul> <li><code>requestId: Long</code> - A unique id, that allows to trace requests in time</li> <li><code>time: SimTime</code></li> <li><code>curComponent: Component?</code></li> <li><code>requester: SimulationEntity</code></li> <li><code>resource: Resource</code></li> <li><code>type: ResourceEventType</code> - Either <code>REQUESTED</code>, <code>CLAIMED</code>, <code>RELEASED</code>, <code>PUT</code> or <code>TAKE</code>.</li> <li><code>quantity: Double</code> </li> </ul>"},{"location":"resource/#resource-activity-event","title":"Resource Activity Event","text":"<p>Events of type <code>org.kalasim.ResourceActivityEvent</code> will be logged at the end of a scoped request block. The following fields are included in each event</p> <ul> <li><code>requested: SimTime</code></li> <li><code>honored: SimTime</code></li> <li><code>released: SimTime</code></li> <li><code>requester: Component</code></li> <li><code>resource: Resource</code></li> <li><code>activity: String</code></li> <li><code>quantity: Double</code></li> </ul>"},{"location":"resource/#activity-log","title":"Activity Log","text":"<p>Resources have a <code>activities</code> attribute that provides a history of scoped requests as a <code>List&lt;ResourceActivityEvent&gt;</code></p> <pre><code>r1.activities\n    .plot(y = { resource.name }, yend = { resource.name }, x = { start }, xend = { end }, color = { activity })\n    .geomSegment(size = 10.0)\n    .yLabel(\"Resource\")\n</code></pre> <p></p> <p>This visualization is also provided by a built-in <code>display()</code> extension for the activity log.</p> <p>There's also a notebook with a complete example.</p>"},{"location":"resource/#timeline","title":"Timeline","text":"<p>The <code>timeline</code> attribute of a resource reports the progression of all its major metrics. The <code>timeline</code> provides a changelog of a resource in terms of:</p> <ul> <li><code>claimed</code> capacity</li> <li><code>capacity</code> of the resource</li> <li><code>availability</code> of the resource</li> <li><code>occupancy</code> of the resource</li> <li><code># requesters</code> in the queue of the resource at a given time</li> <li><code># claimers</code> claiming from the resource at a given time</li> </ul> <p>For convenience also 2 inferrable attributes are also included:</p> <ul> <li><code>availability</code></li> <li><code>occupancy</code></li> </ul> <p>Technically, the <code>timeline</code> is a <code>List&lt;ResourceTimelineSegment&gt;</code> that covers the entire lifespan of the resource as step functions per metric.</p> <p>Example (from example notebook) that illustrates how the <code>timeline</code> can be used to visualize some aspects of the resource utilization over time.</p> <pre><code>r.timeline\n    .filter { listOf(ResourceMetric.Capacity, ResourceMetric.Claimed).contains(it.metric) }\n    .plot(x = { start }, y = { value }, color = { metric })\n    .geomStep()\n    .facetWrap(\"color\", ncol = 1, scales = FacetScales.free_y)\n</code></pre> <p></p> <p>This visualization is also provided by a built-in <code>display()</code> extension for the timeline attribute.</p>"},{"location":"resource/#monitors","title":"Monitors","text":"<p>Resources have a number of monitors:</p> <ul> <li>claimers<ul> <li><code>queueLength</code></li> <li><code>lengthOfStay</code></li> </ul> </li> <li>requesters<ul> <li><code>queueLength</code></li> <li><code>lengthOfStay</code></li> </ul> </li> <li><code>claimedTimeline</code></li> <li><code>availabilityTimeline</code></li> <li><code>capacityTimeline</code></li> <li><code>occupancyTimeline</code>  (= claimed quantity / capacity)</li> </ul> <p>By default, all monitors are enabled.</p> <p>With <code>r.printStatistics()</code> the key statistics of these all monitors are printed. E.g.</p> <pre><code>{\n  \"availableQuantity\": {\n    \"duration\": 3000,\n    \"min\": 0,\n    \"max\": 3,\n    \"mean\": 0.115,\n    \"standard_deviation\": 0.332\n  },\n  \"claimedQuantity\": {\n    \"duration\": 3000,\n    \"min\": 0,\n    \"max\": 3,\n    \"mean\": 2.885,\n    \"standard_deviation\": 0.332\n  },\n  \"occupancy\": {\n    \"duration\": 3000,\n    \"min\": 0,\n    \"max\": 1,\n    \"mean\": 0.962,\n    \"standard_deviation\": 0.111\n  },\n  \"name\": \"clerks\",\n  \"requesterStats\": {\n    \"queue_length\": {\n      \"all\": {\n        \"duration\": 3000,\n        \"min\": 0,\n        \"max\": 3,\n        \"mean\": 0.564,\n        \"standard_deviation\": 0.727\n      },\n      \"excl_zeros\": {\n        \"duration\": 1283.1906989415463,\n        \"min\": 1,\n        \"max\": 3,\n        \"mean\": 1.319,\n        \"standard_deviation\": 0.49\n      }\n    },\n    \"name\": \"requesters of clerks\",\n    \"length_of_stay\": {\n      \"all\": {\n        \"entries\": 290,\n        \"ninety_pct_quantile\": 15.336764014133065,\n        \"median\": 6.97,\n        \"mean\": 5.771,\n        \"ninetyfive_pct_quantile\": 17.9504616361896,\n        \"standard_deviation\": 6.97\n      },\n      \"excl_zeros\": {\n        \"entries\": 205,\n        \"ninety_pct_quantile\": 17.074664209460025,\n        \"median\": 7.014,\n        \"mean\": 8.163,\n        \"ninetyfive_pct_quantile\": 19.28443602612993,\n        \"standard_deviation\": 7.014\n      }\n    },\n    \"type\": \"QueueStatistics\"\n  },\n  \"type\": \"ResourceStatistics\",\n  \"timestamp\": 3000,\n  \"claimerStats\": {\n    \"queue_length\": {\n      \"all\": {\n        \"duration\": 3000,\n        \"min\": 0,\n        \"max\": 3,\n        \"mean\": 2.885,\n        \"standard_deviation\": 0.332\n      },\n      \"excl_zeros\": {\n        \"duration\": 3000,\n        \"min\": 1,\n        \"max\": 3,\n        \"mean\": 2.885,\n        \"standard_deviation\": 0.332\n      }\n    },\n    \"name\": \"claimers of clerks\",\n    \"length_of_stay\": {\n      \"all\": {\n        \"entries\": 287,\n        \"ninety_pct_quantile\": 30,\n        \"median\": 0,\n        \"mean\": 30,\n        \"ninetyfive_pct_quantile\": 30,\n        \"standard_deviation\": 0\n      },\n      \"excl_zeros\": {\n        \"entries\": 287,\n        \"ninety_pct_quantile\": 30,\n        \"median\": 0,\n        \"mean\": 30,\n        \"ninetyfive_pct_quantile\": 30,\n        \"standard_deviation\": 0\n      }\n    },\n    \"type\": \"QueueStatistics\"\n  },\n  \"capacity\": {\n    \"duration\": 3000,\n    \"min\": 3,\n    \"max\": 3,\n    \"mean\": 3,\n    \"standard_deviation\": 0\n  }\n}\n</code></pre> <p>With <code>println(r)</code> a summary of the contents of the queues can be printed. E.g.:</p> <pre><code>{\n  \"claimedQuantity\": 3,\n  \"requestingComponents\": [\n    {\n      \"component\": \"Customer.292\",\n      \"quantity\": 1\n    },\n    {\n      \"component\": \"Customer.291\",\n      \"quantity\": 1\n    }\n  ],\n  \"creationTime\": 0,\n  \"name\": \"clerks\",\n  \"claimedBy\": [\n    {\n      \"first\": \"Customer.288\",\n      \"second\": null\n    },\n    {\n      \"first\": \"Customer.289\",\n      \"second\": null\n    },\n    {\n      \"first\": \"Customer.290\",\n      \"second\": null\n    }\n  ],\n  \"capacity\": 3\n}\n</code></pre> <p>Querying of the capacity, claimed quantity, available quantity and occupancy can be done with: <code>r.capacity</code>, <code>r.claimedQuantity</code>, <code>r.availableQuantity</code> and <code>r.occupancy</code>. All quantities are tracked by corresponding level monitors to provide statistics.</p> <p>If the capacity of a resource is constant, which is very common, the mean occupancy can be found with:</p> <pre><code>r.occupancyMonitor.statistics().mean\n</code></pre> <p>When the capacity changes over time, it is recommended to use:</p> <pre><code>occupancy = r.claimedTimeline.statistics().mean / r.capacityTimeline.statistics().mean()\n</code></pre> <p>to obtain the mean occupancy.</p> <p>Note that the occupancy is set to 0 if the capacity of the resource is &lt;= 0.</p>"},{"location":"resource/#pre-emptive-resources","title":"Pre-emptive Resources","text":"<p>It is possible to specify that a resource is to be preemptive, by adding <code>preemptive = true</code> when the resource is created.</p> <p>If a component requests from a preemptive resource, it may bump component(s) that are claiming from the resource, provided these have a lower priority. If component is bumped, it releases the resource and is then activated, thus essentially stopping the current action (usually <code>hold</code> or <code>passivate</code>).</p> <p>Therefore, a component claiming from a preemptive resource should check whether the component is bumped or still claiming at any point where they can be bumped. This can be done with the method <code>Component.isClaiming(resource)</code> which is <code>true</code> if the component is claiming from the resource, or the opposite (Component.isBumped) which is <code>true</code> is the component is not claiming from the resource.</p> <p>Examples using preemptive resources</p> <ul> <li>Machine Shop</li> </ul>"},{"location":"setup/","title":"Installation","text":"<p><code>kalasim</code> requires Java11 or higher.</p>"},{"location":"setup/#gradle","title":"Gradle","text":"<p>To get started, simply add it as a dependency: <pre><code>dependencies {\n    implementation 'com.github.holgerbrandl:kalasim:1.1.3'\n}\n</code></pre></p> <p>Builds are hosted on maven-central supported by the great folks at sonatype.</p>"},{"location":"setup/#jitpack-integration","title":"Jitpack Integration","text":"<p>You can also use JitPack with Maven or Gradle to include the latest snapshot as a dependency in your project.</p> <pre><code>repositories {\n    maven { url 'https://jitpack.io' }\n}\ndependencies {\n        implementation 'com.github.holgerbrandl:kalasim:-SNAPSHOT'\n}\n</code></pre>"},{"location":"setup/#how-to-build-it-from-sources","title":"How to build it from sources?","text":"<p>To build and install it into your local maven cache, simply clone the repo and run <pre><code>./gradlew install\n</code></pre></p>"},{"location":"state/","title":"State","text":"<p>States provide a powerful tool for process interaction.</p> <p>A state will have a value at any given time. In its simplest form a component can <code>wait()</code> for a specific value of a state. Once that value is reached, the component will be resumed.</p>"},{"location":"state/#examples","title":"Examples","text":"<ul> <li>Traffic</li> <li>Bank Office with 1 clerk</li> <li>Bank Office With Balking And Reneging</li> </ul>"},{"location":"state/#usage","title":"Usage","text":"<p>New States are defined as <code>val doorOpen = State(false)</code>. The initial value is <code>false</code>, meaning the door is closed.</p> <p>Now we can say :</p> <pre><code>doorOpen.value = true\n</code></pre> <p>to open the door.</p> <p>If we want a person to wait for an open door, we could say :</p> <pre><code>wait(doorOpen, true)\n</code></pre> <p>The person's process definition will be suspended until the door is open.</p> <p>We can obtain the current value (e.g. for logging) with:</p> <pre><code>print(\"\"\"door is ${if(doorOpen.value) \"open\" else \"closed\"}\"\"\")\n</code></pre> <p>The value of a state is automatically monitored in the <code>State&lt;T&gt;.timeline</code> level monitor.</p> <p>All components waiting for a state are tracked in a (internal) queue, that can be obtained with <code>doorOpen.waiters</code>.</p>"},{"location":"state/#state-change-triggers","title":"State Change Triggers","text":"<p>If we just want at most one person to enter, we can use <code>trigger()</code> (which is a simple convenience wrapper around <code>wait)</code> with <code>doorOpen.trigger(true, max=1)</code>. The following will happen:</p> <ol> <li>Temporarily change the state to the provided value,</li> <li>Reschedule <code>max</code> components (or less if there are fewer/no <code>waiters</code>) for immediate process continuation,</li> <li>and finally restore the previous state value.</li> </ol>"},{"location":"state/#type-support","title":"Type Support","text":"<p>States support generics, so we could equally well use any other type to model the value. For example, a traffic light could be modelled with a <code>String</code> state:</p> <pre><code>// initially the traffic light is red\nval light = State(\"red\")\n...\n// toggle its value to green\nlight.value = \"green\"\n</code></pre> <p>Or define a int/float state :</p> <pre><code>val level = State(0.0)\n\nlevel.value += 10\n</code></pre> <p>Since <code>State&lt;T&gt;</code> is a generic type, the compiler will reject invalid level associations such as <pre><code>level.value = \"red\"\n</code></pre> This won't compile because the type of level is <code>Double</code>.</p>"},{"location":"state/#metrics","title":"Metrics","text":"<p>States have a number of metrics endpoints:</p> <ul> <li><code>valueMonitor</code> tracks state changes over time</li> <li><code>queueLength</code> tracks the queue length level across time</li> <li><code>lengthOfStay</code> tracks the length of stay in the queue over time</li> </ul>"},{"location":"state/#process-interaction-with-wait","title":"Process interaction with <code>wait()</code>","text":"<p>A component can <code>wait()</code> for a state to get a certain value. In its most simple form this is done with</p> <pre><code>wait(doorOpen, true)\n</code></pre> <p>Once the <code>doorOpen</code> state is <code>true</code>, the component will be scheduled for process continuation.</p> <p>As with <code>request</code> it is possible to set a timeout with <code>failAt</code> or <code>failDelay</code> :</p> <pre><code>wait(dooropen, true, failDelay=10.0)\nif(failed) print(\"impatient ...\")\n</code></pre> <p>In this example, the process will wait at max <code>10</code> ticks. If the state predicate was not met until then, the <code>failed</code> flag will be set and be consumed by the user.</p> <p>There are two ways to test for a value</p> <ul> <li>Value testing</li> <li>Predicate testing</li> </ul>"},{"location":"state/#value-testing","title":"Value Testing","text":"<p>It is possible to test for a certain value:</p> <pre><code>wait(light, \"green\")\n</code></pre> <p>Or more states at once:</p> <p><pre><code>wait(light turns \"green\", light turns \"yellow\")  \n</code></pre> where the wait is honored as soon is light is <code>green</code> OR <code>yellow</code>.</p> <p>It is also possible to wait for all conditions to be satisfied, by adding <code>all=true</code>:</p> <p><pre><code>wait(light turns \"green\", engineRunning turns true, all=true) \n</code></pre> Here, the wait is honored as soon as light is <code>green</code> AND  the engine is running.</p>"},{"location":"state/#predicate-testing","title":"Predicate testing","text":"<p>This is a more complicated but also more versatile way of specifying the honor-condition. In that case, a predicate function <code>(T) -&gt; Boolean</code> must be provided required to specify the condition.</p>"},{"location":"state/#example-1","title":"Example 1","text":"<p><pre><code>val state = State(\"foo\")\nwait(state) { listOf(\"bar\", \"test\").contains(it) }\n</code></pre> The wait is honored if the <code>String</code> State becomes either <code>bar</code> or <code>test</code>.</p>"},{"location":"state/#example-2","title":"Example 2","text":"<pre><code>val intState = State(3.0)\nwait(intState) { it*3 &lt; 42 }\n</code></pre> <p>In this last example the wait is honored as soon as the value fulfils <code>it*3 &lt; 42</code>.</p>"},{"location":"theory/","title":"Simulation Theory","text":"<p>As defined by Shannon (1975),</p> <p>a simulation is the process of designing a model of a real system and conducting experiments with this model for the purpose either of understanding the behavior of the system or of evaluating various strategies (within the limits imposed by a criterion or a set of criteria) for the operation of the system.</p>"},{"location":"theory/#what-is-discrete-event-simulation","title":"What is discrete event simulation?","text":"<p>A discrete event simulation (DES) is a tool that allows studying the dynamic behavior of stochastic, dynamic and discretely evolving systems such as</p> <ul> <li>Factories</li> <li>Ports &amp; Airports</li> <li>Traffic</li> <li>Supply chains &amp; Logistics</li> <li>Controlling</li> </ul> <p>In fact, every process that is founded on discrete state changes is suitable to be simulated with a discrete event simulation such as <code>kalasim</code>.</p> <p>As described by Ucar, 2019, the discrete nature of a given system arises as soon as its behavior can be described in terms of events, which is the most fundamental concept in DES. An event is an instantaneous occurrence that may change the state of the system, while, between events, all the state variables remain.</p> <p>There are several main DES paradigms. In activity-oriented  DES the simulation clock advances in fixed time increments and all simulation entities are scanned and possibly reevaluated. Clearly, simulation performance degrades quickly with smaller increments and increasingly complex models.</p> <p>In event-oriented DES is built around a list of scheduled events ordered by future execution time. During simulation, the these events are processed sequentially to update the state of the model.</p> <p>Finally, process-oriented DES refines the event-oriented approach by defining a vocabulary of interactions to describe the interplay between simulation entities. This vocabulary is used by the modeler to define the component life-cycle processes of each simulation entity.</p>"},{"location":"theory/#applications-of-discrete-event-simulation","title":"Applications of discrete event simulation","text":"<p>Depending on the system in question, DES and <code>kalasim</code> in particular can provide insights into the process efficiency, risks or effectiveness. In addition, it allows assessing alternative what-if scenarios. Very often planning is all about estimating the effect of changes to a system. such as more/fewer driver, more/fewer machines, more/less repair cycles, more/fewer cargo trolleys.</p> <p>Typical applications of discrete event simulations are</p> <ul> <li>Production planning (such as bottleneck analysis)</li> <li>Dimensioning (How many drivers are needed? Number of servers?)</li> <li>Process automation &amp; visualization</li> <li>Digital twin development</li> <li>Project management</li> </ul> <p>For  in-depth primers about simulation see here or Ucar, 2019.</p>"},{"location":"theory/#other-simulation-tools","title":"Other Simulation Tools","text":"<p>There are too many to be listed. In generally there are graphical tools and APIs  . Graphical tools, such as AnyLogic excel by providing a flat learning curve, great visuals but often lack interfaces for extensibility or automation. APIs are usually much more flexible but often lack an intuitive approach to actually build simulations.</p> <p>Out of the great number of APIs, we pinpoint just  those projects/products which served as source of inspiration when developing <code>kalasim</code>.</p>"},{"location":"visualization/","title":"Visualization","text":"<p>There are two type of visualizations</p> <ul> <li>Statistical plots to inspect distributions, trends and outliers. That's what described in this chapter</li> <li>Process rendering to actually show simulation entities, their state or position changes on a 2D (or even 3D) grid as rendered movie. This may also involve interactive controls to adjust simulation parameters. Such functionality is planned but not yet implemented in <code>kalasim</code></li> </ul> <p>Examples * Movie Theater</p>"},{"location":"visualization/#built-in-visualizations","title":"Built-in Visualizations","text":"<p>Currently, the following extensions for distribution analysis are supported</p> <p>Components</p> <p>Monitors</p> <ul> <li><code>CategoryTimeline&lt;T&gt;.display()</code> provides a segment chart of the level</li> <li><code>FrequencyTable&lt;T&gt;.display()</code> provides a barchart of the frequencies of the different values </li> <li><code>NumericStatisticMonitor.display()</code> provides histogram of the underlying distribution</li> <li><code>MetricTimeline.display()</code> provides a line chart with time on the x and the value on y</li> </ul> <p>Resources</p> <ul> <li><code>r.activiities</code> to show the activities as segments timeline</li> <li><code>r.timeline</code> to show the resource utilization and queuing status </li> <li>All monitor related plots from above</li> </ul> <p>Component Queue</p> <ul> <li>All monitor related plots from above</li> </ul> <p>For monitors, see corresponding section</p>"},{"location":"visualization/#framework-support","title":"Framework Support","text":"<p>By default, <code>kalasim</code> supports 2 pluggable visualization backends. Currently kravis and lets-plot are supported.</p> <p>Since we may not be able to support all visualizations in both frontends, the user can simply toggle the frontend by package import:</p> <pre><code>// simply toggle backend by package import\nimport org.kalasim.plot.letsplot.display\n// or\n//import org.kalasim.plot.kravis.display\n\nMM1Queue().apply {\n    run(100)\n    server.claimedMonitor.display()\n}\n</code></pre>"},{"location":"visualization/#kravis","title":"Kravis","text":"<p><code>kalasim</code> integrates nicely with <code>kravis</code> to visualize monitor data. For examples see <code>src/test/kotlin/org/kalasim/analytics/KravisVis.kt</code>.</p> <p>Note</p> <p>To visualize data with kravis, R must be installed on the system. See here) for details.</p>"},{"location":"visualization/#letsplot","title":"LetsPlot","text":"<p>lets-plot is another very modern visualization library that renders within the JVM and thus does not have any external dependencies. Similar to <code>kravis</code> it mimics the API of ggplot2.</p>"},{"location":"animation/lunar_mining/","title":"Lunar Mining","text":"<p>Mining robots scan the surface of the moon for depletable water deposits.</p> <p>From Wikipedia on Lunar Resources</p> <p>The Moon bears substantial natural resources which could be exploited in the future. Potential lunar resources may encompass processable materials such as volatiles and minerals, along with geologic structures such as lava tubes that together, might enable lunar habitation. The use of resources on the Moon may provide a means of reducing the cost and risk of lunar exploration and beyond.</p> <p>In a not so distant future, mankind will have established a permanent base on the moon. To fulfil its demand for water, the Earth Space Agency (ESPA) has decided to deploy a fleet of autonomous water-ice mining robots. These robots are designed to first analyze areas for possible water deposits. Detected deposits will be mined, and ice/water will be shipped and stored in the base station. It is a race against time for life and death, because the astronauts are very thirsty.</p> <p></p> <p> Full moon photograph taken 10-22-2010 from Madison, Alabama, USA; CC BY-SA 3.0 </p> <p>ESPA has ordered their process specialists to work out a simulation model of the mining process. With the simulation, the number of mining robots needed to supply the base with enough water must be determined. Also, water production rates shall be estimated. </p> <p>ESPA simulation engineers have to solve two very typical tasks in industrial engineering</p> <ol> <li>Capacity Planning (number of mining robots needed)</li> <li>Forecast of Production KPIs (tons of water/day)</li> </ol>"},{"location":"animation/lunar_mining/#simulation-model","title":"Simulation Model","text":"<p>There is a complex interplay of rate-limited processes (transport, search, mining), limited resources and the harsh realities of deep space. The latter is abstracted away in the model as it does not contribute to model performance</p> <ul> <li>While the specific locations of ice-deposits are unknown, their average distribution and size on the moon had been determined already using a satellite equipped with the onboard radar, ultraviolet detectors as well as a neutron spectrometer</li> <li>Small harvester robots are being deployed from a central depot to scan the lunar surface for water deposits</li> <li>When finding a depot they deplete it</li> <li>They have a limited storage capacity (100kg), so they will need to shuttle the cargo to the base</li> <li>The base will consume water constantly (exponentially distributed with a mean of 5 kg/h)</li> <li>The base has an initial deposit of 100kg water (which was shipped to the moon very expensively with rockets from earth)</li> <li>Idle harvesters will consult the base for nearby deposits discovered by other units</li> </ul> <p>The complete model definition can be found here. As an example, we inspect the unloading process of water at the base</p> <p><pre><code>fun unload() = sequence {\n    moveTo(base.position)\n\n    val unloadingUnitsPerHours = 20  // speed of unloading\n\n    // unloading time correlates with load status\n    currentState = UNLOADING\n    hold((tank.level / unloadingUnitsPerHours).roundToInt().hours,\n         \"Unloading ${tank.level} water units\")\n\n    // put the water into the refinery of the base\n    put(get&lt;Base&gt;().refinery, tank.level)\n\n     // empty the tank\n    take(tank, tank.level)\n\n    activate(process = Harvester::harvesting)\n}\n</code></pre> Modelled as process definition, it can be easily started with <code>activate()</code>.</p> <p>A state variable <code>currentState</code> allows for later analysis about what the robots were doing. Unloading is actually separated over 2 independent resources:</p> <ul> <li>the tank of the mining robot</li> <li>the refinery of the base</li> </ul> <p>Both are modelled as depletable resource, so they can be consumed and refilled with <code>take()</code> and <code>put()</code> respectively.</p> <p>Once water unloading is complete, another sub-process of the ice harvester is activated: It's going back into harvesting mode, i.e. the robot is returning to its last mined deposit to continue ice collection.</p> <p></p> <p> API surface of the lunar mining simulation model </p>"},{"location":"animation/lunar_mining/#process-animation","title":"Process Animation","text":"<p>The model can be expressed easily in approximately 200 lines of process definitions in <code>LunarMining.kt</code>. Howvever, it was not initially clear, if the intended dynamics were implemented correctly. Process animation comes to resuce, as it allows to debug of the model vsually.</p> <p>A process animation was developed as well to better understand the spatio-temporal dynamics of the model. In LunarMiningHQ.kt the animation of this process is worked out in just about 150 lines of code.</p> <p>We used different capabilties of the animation system (based on OPENRNDR)</p> <ul> <li>Image background to draw a map of the moon</li> <li>Dynamic shape contour to indicate loading status of the harvesters</li> <li>SVG objects for harvesters and base</li> <li>Automatic video recording</li> <li>Text and simple shapes to draw deposits and process properties </li> </ul>"},{"location":"animation/lunar_mining/#supply-optimization","title":"Supply Optimization","text":"<p>To assess how many ice harvesters are needed to ensure base survival we can play what-if with our model. We do so in a fully reproducible manner right in place here. First we load <code>kalasim</code> and import required classes.</p> <pre><code>@file:Repository(\"*mavenLocal\")\n\n%useLatestDescriptors on\n%use kalasim(0.7.94)\n%use kravis(0.8.4)\n\n@file:DependsOn(\"org.kalasim.demo:lunar-mining:1.0-SNAPSHOT\")\n\nimport org.kalasim.demo.moon.*\nimport krangl.asDataFrame\nimport krangl.bindRows\n</code></pre> <p>Next we can run the simulation multiple times with different numbers of robots and compare the outcome.</p> <pre><code>val sims = List(9) { numHarvesters -&gt;\n    List(100) {\n        LunarMining(numHarvesters+1, 15, false, it).apply { run(60*60) }\n    }\n}.flatten()\n</code></pre> <p>To work with the data, we first combine the refinery water level timelines into a data-frame.</p> <pre><code>val waterSupply = sims.withIndex().map { (idx, sim) -&gt;\n    sim.base.refinery.levelTimeline//.statistics()\n        .stepFun()\n        .asDataFrame()\n        .addColumn(\"num_harvesters\") { sim.harvesters.size }\n        .addColumn(\"run\") { idx }\n}.bindRows()\n</code></pre> <p>First, we can study the water level in the central refinery across all the 100 simuation runs.    </p> <pre><code>waterSupply\n     .addColumn(\"num_harvesters\"){\n        it[\"num_harvesters\"].map&lt;Int&gt;{ it.toString()+ \" harvesters\"}\n     }\n    .plot(x = \"time\", y = \"value\", group=\"run\", color=\"num_harvesters\")\n    .geomLine( alpha = .1)\n    .facetWrap(\"num_harvesters\", scales=FacetScales.free_y)\n    .guides(color=LegendType.none)\n</code></pre> <p></p> <p>With more ice harvesters working around the base, supply of water is ensured. Initially there is a phase, were no deposits are yet discovererd, so the base is under a severe risk of running dry. To assess how often this happens, we count the number of runs per harvester where the base's refinery was depleted.  </p> <pre><code>sims.map { sim -&gt;\n    (\"h \"+sim.harvesters.size) to\n            sim.base.refinery.levelTimeline.statistics().min\n}.plot(x={ first}, fill={second==0.0})\n    .geomBar()\n    .labs(x=\"# harvesters\", y=\"# simulation runs\", fill = \"Base Depleted?\")\n</code></pre> <p></p> <p>As shown in the figure, it turns out, that with &gt;=5 ice harvestering robots, the risk of water supply depletion at the base station is within an acceptable range.</p> <p>We have just analyzed our lunar mining model using controlled randomization, and have performed a basic capacity analysis.</p>"},{"location":"animation/lunar_mining/#exercise-maintenance-module","title":"Exercise: Maintenance Module","text":"<p>The model could be extended to model robot health as well</p> <ul> <li>Occasional meteoroids hits will affect the harvester health status (with the varying amount, and which eventually will lead to robot outage)</li> <li>Harvesters health is slowly decreasing while depleting deposits</li> <li>Harvesters can be repaired in a special maintenance depot (which is a bit far off), so they must sure to get their in time because picking up broken robots in the field is very time consumin &amp; expensive</li> </ul>"},{"location":"animation/lunar_mining/#summary","title":"Summary","text":"<p>ESPA is relieved. The simulation model showed that sufficient water-supplies can be gathered with 5 mining robots. The astronauts can even take a shower every Sunday from now on.</p> <p>Using a discrete event simulation model built with <code>kalasim</code>, we have animated the process and have analyzed its statistical properties.</p>"},{"location":"articles/2021-11-27-kalasim-v07/","title":"Kalasim v0.7","text":"<p>After quite some months of exploration, API refinements, countless simulations, and some literature research, we present with great pleasure the next milestone release of kalasim!</p> <p><code>kalasim</code> v0.7 is not just for engineers, but for process analysts and industrial engineers who need to go beyond the limitations of existing simulation tools to model and optimize their business-critical use-cases. So, we deliberately took some time with this release to gather and analyze feedback from our users.</p> <p>With this milestone release, we have stabilized the core API considerably, improved its performance dramatically while adding new features all over the place.</p>"},{"location":"articles/2021-11-27-kalasim-v07/#new-features","title":"New Features","text":"<p>Major enhancements in this release are</p> <ul> <li>Added <code>processRepeated</code> to streamline modelling of reiterating processes</li> <li>Reworked event &amp; metrics logging API for better configurability and performance</li> <li>Introduced <code>ComponentList</code> to provide metrics-enhanced collection similar to the existing <code>ComponentQueue</code></li> <li>Implemented ticks metrics monitor to streamline simulation monitoring</li> <li>Added new timeline and activity log  attributes to resources for streamlined utilization analytics</li> <li>Extended <code>display()</code> support API on all major components and their collections (including <code>Resource</code>, <code>Component</code> or <code>List&lt;Component&gt;</code>, <code>MetricTimeline</code>)</li> <li>Enabled simplified simulation parallelism by changing the dependency context registry to become thread-local</li> <li>Dramatically improved simulation performance to scale at ease to thousands of simulation entities</li> </ul> <p>See <code>kalasim</code>'s changlog for a complete list of technical changes in the v0.7 milestone release</p>"},{"location":"articles/2021-11-27-kalasim-v07/#documentation-improvements","title":"Documentation Improvements","text":"<p>We've rewritten a large part of the documentation for better readability. In particular, we've focussed on resources and components, which are the key elements of every business process model.  A new chapter about collections was added, and the numerous advanced topics were worked out to cover more aspects of the product in much more detail.</p> <p>Several new examples were added including the famous Bridge Games. The ATM was rebuilt using a jupyter-notebook example to better illustrate parallelization and the new visualization support API. Finally, we started a new larger scale example simulation to model the interplay of processes in an emergency room.</p>"},{"location":"articles/2021-11-27-kalasim-v07/#acknowledgments","title":"Acknowledgments","text":"<p>Different individuals and organizations made this milestone release possible. Most importantly, we'd like to thank SYSTEMA GmbH for supporting the project. Special thanks go to Ilya Muradyan and Igor Alshannikov from JetBrains for their patience with us and their wonderful support with Kotlin data-science tooling. We like to thank Arnaud Giuliani for providing great koin support and guidance, which is the basement on which we managed to build <code>kalasim</code>.</p> <p>Finally, we'd like to thank the wonderful folks at CASUS for providing us the opportunity to introduce <code>kalasim</code> to a great simulation experts panel.</p>"},{"location":"articles/2021-11-27-kalasim-v07/#next-steps","title":"Next steps","text":"<p>We're having a packed feature roadmap. On the top of our roadmap are the following ideas</p> <ul> <li>Environment snapshotting &amp; branching: This feature will dramatically ease distributed simulations, prepare for new types of AI connectivity, and will enable confidence bands for projects after user-defined branching events</li> <li>Environment merging: We strive to enable algebraic composability of simulation environments</li> <li>Better examples: Existing examples are intentionally kept small to illustrate the API. Next, we plan to release some large simulations with thousands of simulation entities, along with protocols on how to analyze dynamics in such systems</li> <li>Adopt new Kotlin v1.6 language features such as the new duration API, simplified suspend method semantics, and builder inference improvements</li> </ul> <p>Please note, that the <code>kalasim</code> APIs will be subject to breaking changes until a very distant major release.</p> <p>If you think that <code>kalasim</code> is missing some important feature, please just let us know.</p>"},{"location":"articles/2022-09-27-kalasim-v08/","title":"Kalasim v0.8","text":"<p>After some more months of continued refinements, extensions and refactorings, and - for sure - a sightly number of new simulations across different domains and industries, we present with great pleasure the next milestone v0.8 release of kalasim!</p> <p><code>kalasim</code> v0.8 has matured considerable across the entire API. From a small experimental API it has grown into a battle-tested real-time scalable open-architecture simulation engine, designed not just for engineers, but for business process analysts and industrial engineers who need to go beyond the limitations of existing simulation tools to model and optimize their business-critical use-cases.</p>"},{"location":"articles/2022-09-27-kalasim-v08/#new-features","title":"New Features","text":"<p>With this milestone release, we have further stabilized its core API, improved its performance while adding new features all over the place.</p> <p>Major enhancements in this release are</p> <ul> <li>Support for <code>kotlin.time.Duration</code> across the entire API. Processes can be expressed much more naturally using time-units:</li> </ul> <pre><code>val sim = createSimulation {\n    object : Component() {\n        override fun process() = sequence {\n            hold(3.days)\n            // some action\n            hold(2.minutes)\n        }\n    }\n}\n\nsim.run(3.years)\n</code></pre> <ul> <li> <p>Added new options to model resource honor policies allowing for more configurable request queue consumption <pre><code>val r  = Resource(honorPolicy = RequestHonorPolicy.StrictFCFS)\n</code></pre></p> </li> <li> <p>Added Timeline Arithmetics. It is now possible to perform stream arithmetics on timeline attributes</p> </li> <li>We have reworked and simplified depletable resources. This enables a wide range of new use-cases. See lunar mining for a great example. As part of this feature, we have introduced different request modes to model resources requests that exceed resource capacity.     <pre><code>val tank  = DepletableResource(capacity=100, initialLevel=60)\n\nput(gasSupply, 50, capacityLimitMode = CapacityLimitMode.CAP)\n</code></pre></li> <li>A new animation submodule to visualize process simulations was added. To keep the core API minimalistic, a new dependency adds all required dependencies from OpenRendr. This additional dependency also provides complimentary utilities such as <code>AnimationComponent</code> to streamline rendering. To demonstrate the capabilities, we have worked out several examples such as the moon base and the office tower.</li> </ul> <p>Other notable enhancements in this release are a streamlined predicate consumption in <code>wait()</code>, more supported statistical distributions, improved bottleneck analysis using resource request-ids and <code>RequestScopeContext</code> in honor block. First community PRs were merged, in particular  #35 which improved the support for asynchronous event consumption.</p> <p>For a complete list of technical changes in the v0.8 milestone release check out our change log.</p>"},{"location":"articles/2022-09-27-kalasim-v08/#example-documentation-improvements","title":"Example &amp; Documentation Improvements","text":"<p>Several new examples were added as part of this release. First, we explored resource mining on the moon, where we don't just demonstrate how to model a complex mining and logistics operation, but also showcase how to animate this process. In the office tower we explore capacity planning via an interactive UI to size elevators in a busy office building.</p>"},{"location":"articles/2022-09-27-kalasim-v08/#acknowledgments","title":"Acknowledgments","text":"<p>Different individuals and organizations made this milestone release possible. Most importantly, we'd like to thank SYSTEMA GmbH for supporting the project.     </p>"},{"location":"articles/2022-09-27-kalasim-v08/#next-steps","title":"Next steps","text":"<p>While improving <code>kalasim</code>, we have dropped some roadmap items sketched out earlier.</p> <ul> <li>Environment snapshotting &amp; branching: While we still believe that this would be highly beneficial, the feature is currently blocked by issues with serialization of kotlin objects (in particular coroutines)</li> <li>We have evaluated but eventually dropped the idea of algebraic composability of simulation environments. Mainly because instances of <code>org.kalasim.Environment</code> can be configured to be incompatible on various levels which can't be resolved with a simple <code>+</code></li> </ul> <p>Next on our roadmap are various open tickets as well as the following meta-tasks </p> <ul> <li>The next release is likely to enforce a tick-duration (seconds, hours, etc.) for any simulation. Along with that, to improve the type-safety and readability of process definitions, we will start replacing all - essentially untyped - tick-time duration method arguments with <code>kotlin.time.Duration</code> equivalents.</li> <li>Better examples &amp; better teaching materials: We will continue to release more complex  simulations with thousands of simulation entities (in particular finishing the emergency room), along with protocols on how to analyze and optimize dynamics in such systems.</li> <li>Improved kotlin-jupyter integration to bring more control and introspection functions into the browser.</li> </ul> <p>Please note, that the <code>kalasim</code> APIs will be subject to breaking changes until a first major release.</p> <p>If you think that <code>kalasim</code> is missing some important feature, please just let us know.</p>"},{"location":"articles/2022-11-25-kalasim-at-wsc22/","title":"WSC22","text":"<p><code>kalasim</code> will be very present this year at the Winter Simulation Conference 2022 (Singapore, December 11-14, 2022). Feel welcome to reach out to us at the conference to discuss about simulation, <code>kalasim</code>, process analytics &amp; optimization, or kotlin for data science. We are also ready - and eager - to support you with your simulations written in <code>kalasim</code> at the conference. We intentionally do not have a physical booth - our booth will just be where we meet you!</p> <p></p> <p>As part of the research initiative AISSI, where various partners from industry and academy develop, integrate and apply novel AI-based approaches to bring scheduling to a new level, we have modelled a complex production process with <code>kalasim</code>. By applying reinforcement learning in a framework for autonomous, integrated production and maintenance scheduling, we strive to outperform classical planning methods wrt critical KPIs such as throughput or due date adherence.</p> <p>As part of the Modeling and Simulation of Semiconductor Manufactoring track, we - Holger Brandl (lead dev of kalasim), Philipp Rossbach, and Hajo Terbrack from SYSTEMA GmbH and Tobias Sprogies from NEXPERIA Germany GmbH) - will proudly present our analysis of a complex manufacturing process simulation implemented with <code>kalasim</code>.</p> <p>Maximizing Throughput, Due Date Compliance and Other Partially Conflicting Objectives Using Multifactorial AI-powered Optimization</p> <p>For the abstract see here</p> <p><code>kalasim</code> has grown very quickly from small experimental API into a battle-tested real-time scalable open-architecture next-generation code-first simulation engine, designed not just for engineers, but for business process analysts and industrial engineers who need to go beyond the limitations of existing simulation tools to model and optimize their business-critical use-cases.</p> <p>If you want to get started with <code>kalasim</code>, need support, or if you think that some important feature is yet missing, feel welcome to get in touch.</p>"},{"location":"articles/articles/","title":"Articles","text":"<p>News, articles, and tutorials centering simulation best practices, success stories from industries, and technical deep dives. </p> <p>We've just started this section, so please be a bit patient in here :-)</p>"},{"location":"examples/atm_queue/","title":"ATM Queue","text":""},{"location":"examples/atm_queue/#simple-queue-model","title":"Simple Queue Model","text":"<p>Let's explore the expressiveness of <code>kalasim</code>s process description using a traditional queuing example, the M/M/1. This Kendall's notation describes a single server - here a ATM - with exponentially distributed arrivals, exponential service time and an infinte queue.</p> <p></p> <p>The basic parameters of the system are</p> <ul> <li>\u03bb - people arrival rate at the ATM</li> <li>\u00b5 - money withdrawal rate</li> </ul> <p>If  \u03bb/\u00b5 &gt; 1, the queue is referred to as unstable since there are more arrivals than the ATM can handle. The queue will grow indefinitely.</p> <p>Let's start simply. First, we work out the basic model without much code reusability in mind.</p> <p>The ATM example is inspired from the <code>simmer</code> paper Ucar et al. 2019.</p> <pre><code> val sim = createSimulation {\n    val lambda = 1.5\n    val mu = 1.0\n    val rho = lambda / mu\n\n    println(\n        \"rho is ${rho}. With rho&gt;1 the system would be unstable, \" +\n                \"because there are more arrivals then the atm can serve.\"\n    )\n\n    val atm = Resource(\"atm\", 1)\n\n    class Customer : Component() {\n        val ed = exponential(mu)\n\n        override fun process() = sequence {\n\n            request(atm)\n\n            hold(ed.sample())\n            release(atm)\n        }\n    }\n\n    ComponentGenerator(iat = exponential(lambda)) { Customer() }\n\n    run(2000)\n\n    atm.occupancyTimeline.display()\n    atm.requesters.queueLengthMonitor.display()\n    atm.requesters.lengthOfStayMonitor.display()\n\n    println(\"\\nqueue statistics: ${atm.requesters.lengthOfStayMonitor.statistics()}\")\n}\n</code></pre> <pre><code>rho is 1.5. With rho&gt;1 the system would be unstable, because there are more arrivals then the atm can serve.\n\n\nqueue statistics: {\n  \"entries\": 1312,\n  \"median\": 3.268,\n  \"mean\": 2.061,\n  \"ninety_pct_quantile\": 6.321,\n  \"standard_deviation\": 3.268,\n  \"ninetyfive_pct_quantile\": 9.091\n}\n</code></pre>"},{"location":"examples/atm_queue/#simple-whatif","title":"Simple WhatIf","text":"<p>To explore the impact of <code>lambda</code> and <code>mu</code> on these statistics, we rework the example to become a bit more generic.</p> <pre><code>class AtmCustomer(\n    val mu: Double,\n    val atm: Resource,\n    koin: Koin = DependencyContext.get()\n) : Component(koin = koin) {\n    val ed = exponential(mu)\n\n    override fun process() = sequence {\n        request(atm)\n\n        hold(ed.sample())\n        release(atm)\n    }\n}\n\nclass AtmQueue(val lambda: Double, val mu: Double) : Environment() {\n    val atm = dependency { Resource(\"atm\", 1) }\n\n    init {\n        ComponentGenerator(iat = exponential(lambda)) {\n            AtmCustomer(mu, atm, koin = getKoin())\n        }\n    }\n}\n</code></pre> <p>Then, we evaluate a parameter grid.</p> <pre><code>   // build parameter grid\nval lambdas = (1..20).map { 0.25 }.cumSum()\nval mus = (1..20).map { 0.25 }.cumSum()\n\n// run 100x times\nval atms = cartesianProduct(lambdas, mus).map { (lambda, mu) -&gt;\n    AtmQueue(lambda, mu).apply { run(100) }\n}\n</code></pre> <p>We now extract the ATM parameters along with he mean queue length of each ATM instance into a data-frame.</p> <pre><code>atms.map {\n    it to it.get&lt;Resource&gt;().statistics.requesters.lengthStats.mean!!.roundAny(2)\n}.toList()\n    .asDataFrame()\n    .unfold&lt;AtmQueue&gt;(\"first\", listOf(\"mu\", \"lambda\"), keep=false)\n    .rename(\"second\" to \"mean_queue_length\")\n</code></pre> mean_queue_lengthlambdamu8.250.250.25113.830.250.5149.730.250.75172.690.251.0178.590.251.25206.610.251.5188.260.251.75205.890.252.0209.680.252.25210.420.252.5<p>... with 390 more rows. Shape: 400 x 3.  </p>"},{"location":"examples/atm_queue/#parallel-whatif","title":"Parallel WhatIf","text":"<p>Very often, simulation models are complex, so running different simulations in parellel allows to minimize overall execution time</p> <p>First, we build a number of sims (as <code>Sequence</code>) and work them out in parallel using kotlin coroutines.</p> <pre><code>val atms = cartesianProduct(lambdas, mus).asIterable().map { (lambda, mu) -&gt;\n    // instantiate sequentially to simplify dependency injection\n    AtmQueue(lambda, mu)\n}.toList()\n\n// define parallelization helper to run in parallel\n// https://stackoverflow.com/questions/34697828/parallel-operations|-on-kotlin-collections\nfun &lt;A, B&gt; Iterable&lt;A&gt;.pmap(f: suspend (A) -&gt; B): List&lt;B&gt; = runBlocking {\n    map { async(newFixedThreadPoolContext(4, \"\")) { f(it) } }.map { it.await() }\n}\n\n// simulate in parallel\natms.pmap {\n    it.run(100)\n}.forEach{} // supppress the output\n</code></pre> <p>Something really cool has just happened. We have run as many simulations in parallel as there are cores on this computer.</p> <p>Next, we can summarize our findings by visualizing the results in usin a heatmap.</p> <pre><code>// extract stats and visualize\nval meanQLength = atms.map { it to it.get&lt;Resource&gt;().statistics.requesters.lengthStats.mean!! }\n\nmeanQLength.plot(x = { first.lambda }, y = { first.mu }, fill = { second })\n    .geomTile()\n    .title(\"Mean ATM Queue Length vs Labmda and Mu\")\n    .xLabel(\"Labmda\").yLabel(\"Mu\")\n</code></pre> <p></p>"},{"location":"examples/atm_queue/#conclusion","title":"Conclusion","text":"<p>In this example we have explored a simple simulation model. In in fact we have not built just a single model, but instead we have modelled a range of ATMs with differeing settings to better understand the dynamics of the process at hand.</p> <p>For complete sources, also see the jupyter notebook or plain kotlin sources. Feel welcome to get in touch for support, suggestions, and questions.</p>"},{"location":"examples/bank_office/","title":"Bank Office","text":"<p>Queue problems are common-place application of discrete event simulation.</p> <p>Often there are multiple solutions for a model. Here we model similar problems - a customer queue -  differently using resources, states and queues in various configurations and interaction patterns.</p>"},{"location":"examples/bank_office/#simple-bank-office-1-clerk","title":"Simple Bank Office (1 clerk)","text":"<p>Lets start with a bank office where customers are arriving in a bank, where there is one clerk. This clerk handles the customers in a first in first out (FIFO) order.</p> <p>We see the following processes:</p> <ul> <li>The customer generator that creates the customers, with an inter-arrival time of <code>uniform(5,15)</code></li> <li>The customers</li> <li>The clerk, which serves the customers in a constant time of 30 (overloaded and non steady state system)</li> </ul> <p>We need a queue for the customers to wait for service.</p> <p>The model code is:</p> <pre><code>////Bank1clerk.kt\npackage org.kalasim.examples.bank.oneclerk\n\nimport org.kalasim.*\nimport org.kalasim.misc.printThis\nimport org.koin.core.component.inject\nimport kotlin.time.Duration\nimport kotlin.time.Duration.Companion.hours\nimport kotlin.time.Duration.Companion.minutes\n\n\nclass Customer(\n    val waitingLine: ComponentQueue&lt;Customer&gt;,\n    val clerk: Clerk\n) : Component() {\n    override fun process() = sequence {\n        waitingLine.add(this@Customer)\n\n        if(clerk.isPassive) clerk.activate()\n\n        passivate()\n    }\n}\n\n\nclass Clerk(val serviceTime: Duration = 10.minutes) : Component() {\n    val waitingLine: ComponentQueue&lt;Customer&gt; by inject()\n\n    override fun process() = sequence {\n        while(true) {\n            while(waitingLine.isEmpty()) passivate()\n\n            val customer = waitingLine.poll()\n\n            hold(serviceTime) // bearbeitungszeit\n            customer.activate()\n        }\n    }\n}\n\nclass CustomerGenerator : Component() {\n\n    override fun process() = sequence {\n        while(true) {\n            Customer(get(), get())\n\n            hold(uniform(5.minutes, 15.minutes).sample())\n        }\n    }\n}\n\n\nfun main() {\n    val deps = declareDependencies {\n        dependency { Clerk() }\n        dependency { ComponentQueue&lt;Customer&gt;(\"waiting line\") }\n    }\n\n    val env = createSimulation(dependencies = deps) {\n        enableComponentLogger()\n\n        CustomerGenerator()\n    }\n\n    env.run(50.hours)\n\n    val waitingLine: ComponentQueue&lt;Customer&gt; = env.get()\n\n    waitingLine.statistics.printThis()\n\n//    if(canDisplay()) {\n//        waitingLine.queueLengthTimeline.display()\n//        waitingLine.lengthOfStayStatistics.display()\n//    }\n}\n</code></pre> <p>Let's look at some details (marked in yellow for convenience).</p> <p>With:</p> <pre><code>waitingLine.add(this@Customer)\n</code></pre> <p>the customer places itself at the tail of the waiting line.</p> <p>Then, the customer checks whether the clerk is idle, and if so, activates him immediately.:</p> <pre><code>if (clerk.isPassive) clerk.activate()\n</code></pre> <p>Once the clerk is active (again), it gets the first customer out of the waitingline with:</p> <pre><code>val customer = waitingLine.poll()\n</code></pre> <p>and holds for 10 days units with:</p> <pre><code>hold(10.days)\n</code></pre> <p>After that hold the customer is activated and will terminate:</p> <pre><code>customer.activate()\n</code></pre> <p>In the main section of the program, we create the <code>CustomerGenerator</code>, the <code>Clerk</code> and a <code>ComponentQueue</code> called waitingline. Here the customer generator is implemented as a custom instance of <code>Component</code> for educational puroposes. Using the provided <code>ComponentGenerator</code> API would be more concise.</p> <pre><code>hold(uniform(5.0, 15.0).sample())\n</code></pre> <p>will do the statistical sampling and wait for that time till the next customer is created.</p> <p>Since logging is enabled when creating the simulation with <code>createSimulation</code> the following log trace is being produced</p> <pre><code>time      current component        action                                       info                               \n--------- ------------------------ -------------------------------------------- ----------------------------------\n.00                                main create\n.00       main\n.00                                Clerk.1 create\n.00                                Clerk.1 activate                             scheduled for .00\n.00                                CustomerGenerator.1 create\n.00                                CustomerGenerator.1 activate                 scheduled for .00\n.00                                main run +50.00                              scheduled for 50.00\n.00       Clerk.1\n.00                                Clerk.1 passivate\n.00       CustomerGenerator.1\n.00                                Customer.1 create\n.00                                Customer.1 activate                          scheduled for .00\n.00                                CustomerGenerator.1 hold +11.95              scheduled for 11.95\n.00       Customer.1\n.00                                Customer.1 entering waiting line\n.00                                Clerk.1 activate                             scheduled for .00\n.00                                Customer.1 passivate\n.00       Clerk.1\n.00                                Customer.1 leaving waiting line\n.00                                Clerk.1 hold +10.00                          scheduled for 10.00\n10.00                              Clerk.1\n10.00                              Customer.1 activate                          scheduled for 10.00\n10.00                              Clerk.1 passivate\n10.00     Customer.1\n10.00                              Customer.1 ended\n11.95     CustomerGenerator.1\n11.95                              Customer.2 create\n11.95                              Customer.2 activate                          scheduled for 11.95\n11.95                              CustomerGenerator.1 hold +7.73               scheduled for 19.68\n11.95     Customer.2\n11.95                              Customer.2 entering waiting line\n11.95                              Clerk.1 activate                             scheduled for 11.95\n11.95                              Customer.2 passivate\n11.95     Clerk.1\n11.95                              Customer.2 leaving waiting line\n11.95                              Clerk.1 hold +10.00                          scheduled for 21.95\n19.68     CustomerGenerator.1\n19.68                              Customer.3 create\n19.68                              Customer.3 activate                          scheduled for 19.68\n19.68                              CustomerGenerator.1 hold +10.32              scheduled for 30.00\n19.68     Customer.3\n19.68                              Customer.3 entering waiting line\n19.68                              Customer.3 passivate\n21.95     Clerk.1\n21.95                              Customer.2 activate                          scheduled for 21.95\n21.95                              Customer.3 leaving waiting line\n21.95                              Clerk.1 hold +10.00                          scheduled for 31.95\n21.95     Customer.2\n21.95                              Customer.2 ended\n30.00     CustomerGenerator.1\n30.00                              Customer.4 create\n30.00                              Customer.4 activate                          scheduled for 30.00\n30.00                              CustomerGenerator.1 hold +10.63              scheduled for 40.63\n30.00     Customer.4\n30.00                              Customer.4 entering waiting line\n30.00                              Customer.4 passivate\n31.95     Clerk.1\n31.95                              Customer.3 activate                          scheduled for 31.95\n31.95                              Customer.4 leaving waiting line\n31.95                              Clerk.1 hold +10.00                          scheduled for 41.95\n31.95     Customer.3\n31.95                              Customer.3 ended\n40.63     CustomerGenerator.1\n40.63                              Customer.5 create\n40.63                              Customer.5 activate                          scheduled for 40.63\n40.63                              CustomerGenerator.1 hold +5.31               scheduled for 45.95\n40.63     Customer.5\n40.63                              Customer.5 entering waiting line\n40.63                              Customer.5 passivate\n41.95     Clerk.1\n41.95                              Customer.4 activate                          scheduled for 41.95\n41.95                              Customer.5 leaving waiting line\n41.95                              Clerk.1 hold +10.00                          scheduled for 51.95\n41.95     Customer.4\n41.95                              Customer.4 ended\n45.95     CustomerGenerator.1\n45.95                              Customer.6 create\n45.95                              Customer.6 activate                          scheduled for 45.95\n45.95                              CustomerGenerator.1 hold +12.68              scheduled for 58.63\n45.95     Customer.6\n45.95                              Customer.6 entering waiting line\n45.95                              Customer.6 passivate\n50.00     main\n</code></pre> <p>After the simulation is finished, the statistics of the queue are presented with:</p> <pre><code>waitingLine.stats.print()\n</code></pre> <p>The statistics output looks like</p> <pre><code>{\n  \"queue_length\": {\n    \"all\": {\n      \"duration\": 50,\n      \"min\": 0,\n      \"max\": 1,\n      \"mean\": 0.15,\n      \"standard_deviation\": 0.361\n    },\n    \"excl_zeros\": {\n      \"duration\": 7.500540828621098,\n      \"min\": 1,\n      \"max\": 1,\n      \"mean\": 1,\n      \"standard_deviation\": 0\n    }\n  },\n  \"name\": \"waiting line\",\n  \"length_of_stay\": {\n    \"all\": {\n      \"entries\": 5,\n      \"ninety_pct_quantile\": 3.736,\n      \"median\": 1.684,\n      \"mean\": 1.334,\n      \"ninetyfive_pct_quantile\": 3.736,\n      \"standard_deviation\": 1.684\n    },\n    \"excl_zeros\": {\n      \"entries\": 3,\n      \"ninety_pct_quantile\": 3.736,\n      \"median\": 1.645,\n      \"mean\": 2.223,\n      \"ninetyfive_pct_quantile\": 3.736,\n      \"standard_deviation\": 1.645\n    }\n  },\n  \"type\": \"QueueStatistics\",\n  \"timestamp\": 50\n}\n</code></pre>"},{"location":"examples/bank_office/#bank-office-with-3-clerks","title":"Bank Office with 3 Clerks","text":"<p>Now, let's add more clerks:</p> <pre><code>add { (1..3).map { Clerk() } }\n</code></pre> <p>And, every time a customer enters the waiting line, we need to make sure at least one passive clerk (if any) is activated:</p> <pre><code>for (c in clerks) {\n    if (c.isPassive) {\n        c.activate()\n        break // activate at max one clerk\n    }\n}\n</code></pre> <p>The complete source of a three clerk post office:</p> <pre><code>////Bank3Clerks.kt\npackage org.kalasim.examples.bank.threeclerks\n\nimport org.kalasim.*\nimport org.koin.core.component.inject\nimport kotlin.time.Duration.Companion.minutes\n\n\nclass CustomerGenerator : Component() {\n\n    override fun process() = sequence {\n        while(true) {\n            Customer(get())\n            hold(uniform(5.0, 15.0).minutes.sample())\n        }\n    }\n}\n\nclass Customer(val waitingLine: ComponentQueue&lt;Customer&gt;) : Component() {\n    private val clerks: List&lt;Clerk&gt; by inject()\n\n    override fun process() = sequence {\n        waitingLine.add(this@Customer)\n\n        for(c in clerks) {\n            if(c.isPassive) {\n                c.activate()\n                break // activate at max one clerk\n            }\n        }\n\n        passivate()\n    }\n}\n\n\nclass Clerk : Component() {\n    private val waitingLine: ComponentQueue&lt;Customer&gt; by inject()\n\n    override fun process() = sequence {\n        while(true) {\n            if(waitingLine.isEmpty())\n                passivate()\n\n            val customer = waitingLine.poll()\n            hold(30.minutes) // bearbeitungszeit\n            customer.activate() // signal the customer that's all's done\n        }\n    }\n}\n\n\nfun main() {\n    createSimulation {\n        dependency { ComponentQueue&lt;Customer&gt;(\"waitingline\") }\n        dependency { State(false, \"worktodo\") }\n        dependency { CustomerGenerator() }\n        dependency { (1..3).map { Clerk() } }\n\n        run(50000.minutes)\n\n        val waitingLine: ComponentQueue&lt;Customer&gt; = get()\n\n//        if(canDisplay()) {\n////        waitingLine.lengthOfStayMonitor.printHistogram()\n////        waitingLine.queueLengthMonitor.printHistogram()\n//\n//            waitingLine.queueLengthTimeline.display()\n//            waitingLine.lengthOfStayStatistics.display()\n        waitingLine.queueLengthTimeline.printSummary()\n        waitingLine.queueLengthTimeline.printSummary()\n\n//        }\n\n//        waitingLine.stats.toJson().toString(2).printThis()\n        waitingLine.printSummary()\n    }\n}\n</code></pre>"},{"location":"examples/bank_office/#bank-office-with-resources","title":"Bank Office with Resources","text":"<p><code>kalasim</code> contains another useful concept for modelling: Resources. Resources have a limited capacity and can be claimed by components and released later.</p> <p>In the model of the bank with the same functionality as the above example, the clerks are defined as a resource with capacity 3.</p> <p>The model code is:</p> <pre><code>////Bank3ClerksResources.kt\npackage org.kalasim.examples.bank.resources\n\nimport org.kalasim.*\nimport kotlin.time.Duration.Companion.days\nimport kotlin.time.Duration.Companion.minutes\n\n\nclass Customer(private val clerks: Resource) : Component() {\n\n    override fun process() = sequence {\n        request(clerks)\n        hold(30.minutes)\n        release(clerks) // not really required\n    }\n}\n\n\nfun main() {\n    val env = createSimulation {\n        dependency { Resource(\"clerks\", capacity = 3) }\n\n        ComponentGenerator(iat = uniform(5.0, 15.0).minutes) { Customer(get()) }\n    }\n\n    env.run(3.days)\n\n    env.get&lt;Resource&gt;().apply {\n        printSummary()\n\n//        if(canDisplay()) {\n//            claimedTimeline.display()\n//            requesters.queueLengthTimeline.display()\n//        }\n\n        printStatistics()\n    }\n}\n</code></pre> <p>Let's look at some details.:</p> <pre><code>add { Resource(\"clerks\", capacity = 3) }\n</code></pre> <p>This defines a resource with a capacity of <code>3</code>.</p> <p>Each customer tries to claim one unit (=clerk) from the resource with:</p> <pre><code>request(clerks)\n</code></pre> <p>B default 1 unit will be requested. If the resource is not available, the customer needs to wait for it to become available (in order of arrival).</p> <p>In contrast with the previous example, the customer now holds itself for 30 time units (clicks). After this time, the customer releases the resource with:</p> <pre><code>release(clerks)\n</code></pre> <p>The effect is that <code>kalasim</code> then tries to honor the next pending request, if any.</p> <p>In this case the release statement is not required, as resources that were claimed are automatically released when a process terminates).`</p> <p>The statistics are maintained in two system queues, called <code>clerk.requesters</code> and <code>clerk.claimers</code>.</p> <p>The output is very similar to the earlier example. The statistics are exactly the same.</p>"},{"location":"examples/bank_office/#bank-office-with-balking-and-reneging","title":"Bank Office with Balking and Reneging","text":"<p>Now, we assume that clients are not going to the queue when there are more than 5 clients waiting (balking). On top of that, if a client is waiting longer than 50, he/she will leave as well (reneging).</p> <p>The model code is:</p> <pre><code>////Bank3ClerksReneging.kt\npackage org.kalasim.examples.bank.reneging\n\nimport org.kalasim.*\nimport org.kalasim.misc.printThis\nimport org.kalasim.monitors.printHistogram\nimport org.koin.core.component.inject\nimport kotlin.time.Duration.Companion.minutes\n\n\n//**{todo}** use monitors here and maybe even inject them\n//to inject use data class Counter(var value: Int)\nvar numBalked: Int = 0\nvar numReneged: Int = 0\n\nclass CustomerGenerator : Component() {\n\n    override fun process() = sequence {\n        while(true) {\n            Customer(get())\n            hold(uniform(5.0, 15.0).minutes.sample())\n        }\n    }\n}\n\nclass Customer(val waitingLine: ComponentQueue&lt;Customer&gt;) : Component() {\n    private val clerks: List&lt;Clerk&gt; by inject()\n\n    override fun process() = sequence {\n        if(waitingLine.size &gt;= 5) {\n            numBalked++\n\n            log(\"balked\")\n            cancel()\n        }\n\n        waitingLine.add(this@Customer)\n\n        for(c in clerks) {\n            if(c.isPassive) {\n                c.activate()\n                break // activate only one clerk\n            }\n        }\n\n        hold(50.minutes) // if not serviced within this time, renege\n\n        if(waitingLine.contains(this@Customer)) {\n            //  this@Customer.leave(waitingLine)\n            waitingLine.remove(this@Customer)\n\n            numReneged++\n            log(\"reneged\")\n        } else {\n            // if customer no longer in waiting line,\n            // serving has started meanwhile\n            passivate()\n        }\n    }\n}\n\n\nclass Clerk : Component() {\n    private val waitingLine: ComponentQueue&lt;Customer&gt; by inject()\n\n    override fun process() = sequence {\n        while(true) {\n            if(waitingLine.isEmpty())\n                passivate()\n\n            val customer = waitingLine.poll()\n            customer.activate() // get the customer out of it's hold(50)\n\n            hold(30.minutes) // bearbeitungszeit\n            customer.activate() // signal the customer that's all's done\n        }\n    }\n}\n\n\nfun main() {\n    val env = createSimulation {\n        enableComponentLogger()\n\n        // register components needed for dependency injection\n        dependency { ComponentQueue&lt;Customer&gt;(\"waitingline\") }\n        dependency { (0..2).map { Clerk() } }\n\n        // register other components to  be present when starting the simulation\n        CustomerGenerator()\n\n        val waitingLine: ComponentQueue&lt;Customer&gt; = get()\n\n        waitingLine.lengthOfStayStatistics.enabled = false\n        run(1500.minutes)\n\n        waitingLine.lengthOfStayStatistics.enabled = true\n        run(500.minutes)\n\n        // with console\n        waitingLine.lengthOfStayStatistics.printHistogram()\n        waitingLine.queueLengthTimeline.printHistogram()\n\n        // with kravis\n//        waitingLine.queueLengthMonitor.display()\n//        waitingLine.lengthOfStayMonitor.display()\n\n        waitingLine.statistics.toJson().toString(2).printThis()\n\n        println(\"number reneged: $numReneged\")\n        println(\"number balked: $numBalked\")\n    }\n}\n</code></pre> <p>Let's look at some details.</p> <pre><code>cancel()\n</code></pre> <p>This makes the current component (a customer) a <code>DATA</code> component (and be subject to garbage collection), if the queue length is <code>5</code> or more.</p> <p>The reneging is implemented after a hold of 50 minutes. If a clerk can service a customer, it will take the customer out of the waitingline and will activate it at that moment. The customer just has to check whether he/she is still in the waiting line. If so, he/she has not been serviced in time and thus will renege.</p> <pre><code>hold(50.minutes)\n\nif (waitingLine.contains(this@Customer)) {\n    waitingLine.leave(this@Customer)\n\n    numReneged++\n    printTrace(\"reneged\")\n} else {\n    passivate()\n}\n</code></pre> <p>All the clerk has to do when starting servicing a client is to get the next customer in line out of the queue (as before) and activate this customer (at time now). The effect is that the hold of the customer will end.</p> <pre><code>hold(30.minutes) \ncustomer.activate() // signal the customer that's all's done\n</code></pre>"},{"location":"examples/bank_office/#bank-office-with-balking-and-reneging-resources","title":"Bank Office with Balking and Reneging (resources)","text":"<p>Now we show how  balking and reneging can be implemented with resources.</p> <p>The model code is:</p> <pre><code>////Bank3ClerksRenegingResources.kt\npackage org.kalasim.examples.bank.reneging_resources\n\n\nimport org.kalasim.*\nimport org.kalasim.monitors.printHistogram\nimport kotlin.time.Duration.Companion.minutes\n\n\n//var numBalked = LevelMonitoredInt(0)\nvar numBalked = 0\nvar numReneged = 0\n\n\nclass Customer(val clerks: Resource) : Component() {\n\n    override fun process() = sequence {\n        if(clerks.requesters.size &gt;= 5) {\n            numBalked++\n            log(\"balked\")\n            cancel()\n        }\n\n        request(clerks, failDelay = 50.minutes)\n\n        if(failed) {\n            numReneged++\n            log(\"reneged\")\n        } else {\n            hold(30.minutes)\n            release(clerks)\n        }\n    }\n}\n\nfun main() {\n    createSimulation {\n        dependency { Resource(\"clerks\", capacity = 3) }\n\n        // register other components to  be present when starting the simulation\n        ComponentGenerator(iat = uniform(5.0, 15.0).minutes) {\n            Customer(get())\n        }\n\n        run(50000.minutes)\n\n        val clerks = get&lt;Resource&gt;()\n\n        // with console\n        clerks.requesters.queueLengthTimeline.printHistogram()\n        clerks.requesters.lengthOfStayStatistics.printHistogram()\n\n        // with kravis\n//        clerks.requesters.queueLengthMonitor.display()\n//        clerks.requesters.lengthOfStayMonitor.display()\n\n        println(\"number reneged: $numReneged\")\n        println(\"number balked: $numBalked\")\n    }\n}\n</code></pre> <p>As you can see, the balking part is exactly the same as in the example without resources.</p> <p>For the renenging, all we have to do is add a <code>failDelay</code>:</p> <pre><code>request(clerks, failDelay = 50.asDist())\n</code></pre> <p>If the request is not honored within <code>50</code> time units (ticks), the process continues after that <code>request</code> statement. We check whether the request has failed with the built-in <code>Component</code> property:</p> <pre><code>iff (failed)\n    numReneged++\n</code></pre> <p>This example shows clearly the advantage of the resource solution over the <code>passivate</code>/<code>activate</code> method, in former example.</p>"},{"location":"examples/bank_office/#bank-office-with-states","title":"Bank Office with States","text":"<p>Another useful concept for modelling are states. In this case, we define a state called <code>worktodo</code>.</p> <p>The model code is:</p> <pre><code>////Bank3ClerksState.kt\n\npackage org.kalasim.examples.bank.state\n\nimport org.apache.commons.math3.distribution.UniformRealDistribution\nimport org.kalasim.*\nimport org.koin.core.component.inject\nimport kotlin.time.Duration.Companion.minutes\n\nclass CustomerGenerator : Component() {\n\n    override fun process() = sequence {\n        while(true) {\n            Customer(get(), get())\n            hold(UniformRealDistribution(env.rg, 5.0, 15.0).minutes.sample())\n        }\n    }\n}\n\nclass Customer(val workTodo: State&lt;Boolean&gt;, val waitingLine: ComponentQueue&lt;Customer&gt;) : Component() {\n    override fun process() = sequence {\n        waitingLine.add(this@Customer)\n        workTodo.trigger(true, max = 1)\n        passivate()\n    }\n}\n\n\nclass Clerk : Component() {\n    val waitingLine: ComponentQueue&lt;Customer&gt; by inject()\n    val workTodo: State&lt;Boolean&gt; by inject()\n\n    override fun process() = sequence {\n        while(true) {\n            if(waitingLine.isEmpty())\n                wait(workTodo, true)\n\n            val customer = waitingLine.poll()\n\n            hold(32.minutes) // bearbeitungszeit\n            customer.activate()\n        }\n    }\n}\n\n\nfun main() {\n    val env = declareDependencies {\n        // register components needed for dependency injection\n        dependency { ComponentQueue&lt;Customer&gt;(\"waitingline\") }\n        dependency { State(false, \"worktodo\") }\n\n    }.createSimulation {\n        enableComponentLogger()\n\n        // register other components to  be present\n        // when starting the simulation\n        repeat(3) { Clerk() }\n        CustomerGenerator()\n\n    }\n\n    env.run(500.minutes)\n\n    println(env.get&lt;ComponentQueue&lt;Customer&gt;&gt;().statistics)\n    env.get&lt;State&lt;Boolean&gt;&gt;().printSummary()\n\n//    val waitingLine: ComponentQueue&lt;Customer&gt; = env.get()\n//    waitingLine.stats.print()\n//    waitingLine.queueLengthMonitor.display()\n}\n</code></pre> <p>Let's look at some details.</p> <pre><code>add { State(false, \"worktodo\") }\n</code></pre> <p>This defines a state with an initial value <code>false</code> and registers it as a dependency.</p> <p>In the code of the customer, the customer tries to trigger one clerk with:</p> <pre><code>workTodo.trigger(true, max = 1)\n</code></pre> <p>The effect is that if there are clerks waiting for worktodo, the first clerk's wait is honored and that clerk continues its process after:</p> <pre><code>wait(workTodo, true)\n</code></pre> <p>Note that the clerk is only going to wait for worktodo after completion of a job if there are no customers waiting.</p>"},{"location":"examples/bank_office/#bank-office-with-standby","title":"Bank Office with Standby","text":"<p>The <code>kalasim</code> package contains yet another powerful process mechanism, called standby. When a component is in <code>STANDBY</code> mode, it will become current after each event. Normally, the standby will be used in a while loop where at every event one or more conditions are checked.</p> <p>The model with standby is:</p> <pre><code>////Bank3ClerksStandby.kt\nimport org.kalasim.*\nimport org.koin.core.component.inject\nimport kotlin.time.Duration.Companion.minutes\n\n\nclass Customer(val waitingLine: ComponentQueue&lt;Customer&gt;) : Component() {\n    override fun process() = sequence {\n        waitingLine.add(this@Customer)\n        passivate()\n    }\n}\n\n\nclass Clerk : Component() {\n    val waitingLine: ComponentQueue&lt;Customer&gt; by inject()\n\n    override fun process() = sequence {\n        while(true) {\n            while(waitingLine.isEmpty())\n                standby()\n\n            val customer = waitingLine.poll()\n            hold(32.minutes) // bearbeitungszeit\n            customer.activate()\n        }\n    }\n}\n\n\nfun main() {\n    val env = createSimulation {\n        dependency { ComponentQueue&lt;Customer&gt;(\"waitingline\") }\n\n        enableComponentLogger()\n\n        repeat(3) { Clerk() }\n\n        ComponentGenerator(uniform(5, 15).seconds) { Customer(get()) }\n    }\n\n    env.run(500.minutes)\n\n    env.get&lt;ComponentQueue&lt;Customer&gt;&gt;().apply {\n        printSummary()\n\n        println(statistics)\n//        lengthOfStayStatistics.display()\n    }\n}\n</code></pre> <p>In this case, the condition is checked frequently with:</p> <pre><code>while(waitingLine.isEmpty())\n    standby()\n</code></pre> <p>The rest of the code is very similar to the version with states.</p> <p>Warning</p> <p>It is very important to realize that this mechanism can have significant impact on the performance, as after EACH event, the component becomes current and has to be checked. In general, it is recommended to try and use states or a more straightforward <code>passivate</code>/<code>activate</code> construction.</p>"},{"location":"examples/bridge_game/","title":"The Bridge Game","text":"<p>The glass bridge is a game in the Netflix series The Squid Game. The series is Netflix's most-watched series to date, becoming the top-viewed program in 94 countries and attracting more than 142 million member households during its first four weeks from launch. (Source Wikipedia)</p> <p>Spoiler Alert Don't read the article if you intend to watch the series!</p> <p></p> <p> Squid Game - \u00a9 Netflix 2021 </p> <p>In one scene in Episode 7, 16 players have to cross a bridge made of two rows of glass tiles. The bridge is 18 steps long. They have to jump to one tile per row, but just one tile will last whereas the other one is made of tempered glass, which breaks under impact. The players start in an ordered fashion, whereby players with higher numbers will avoid broken tiles. To penalize players with higher numbers, there is a time-limit after which players who have not passed the bridge have lost as well (and pay with their lives).</p> <p>Disclaimer The author considers the game purely from a scientific/fictional perspective. The game as well as  the concept of the series are immoral, wrong, and detestable.</p> <p></p> <p> Squid Game - \u00a9 Netflix 2021 </p> <p>Inspired by another simulation this example illustrates how to run simulations in different configurations many times to work out process parameters. Here, the key parameter of interest is the number of surviving players.</p> <p>As players in the show can pick their start number, the episode - as well as the internet community - circles around the question regarding an optimal start number to optimize the chance of survival.</p>"},{"location":"examples/bridge_game/#model","title":"Model","text":"<p>To answer this question, we will model and analyze the process with <code>kalasim</code>. At its heart - which is its process definition -  it is a very simplistic model that centers around simulating the participant's stepping on the tiles one after another while considering the learning experience of earlier participants with lower start numbers.</p> <pre><code>class SquidGame(\n    val numSteps: Int = 18,\n    val numPlayers: Int = 16,\n    val maxDuration: Int = 12 * 60\n) : Environment(randomSeed =Random.nextInt()) {\n\n    // randomization\n    val stepTime = LogNormalDistribution(rg, 3.0, 0.88)\n//    val stepTime = uniform(10,30)\n\n    val decision = enumerated(true, false)\n\n    // state\n    var stepsLeft = numSteps\n    var survivors= mutableListOf&lt;Int&gt;()\n\n    val numTrials: Int\n        get() = numSteps - survivors.size\n\n    val numSurvivors : Int\n       get() = survivors.size\n\n    fun playerSurvived(playerNo: Int) = survivors.contains(playerNo)\n\n    init {\n        object : Component() {\n            override fun process() = sequence {\n               queue@\n               for(player in 1..numPlayers){\n                    hold(min(stepTime(), 100.0)) // cap time at 100sec\n\n                    while(stepsLeft-- &gt; 0){\n                        if(decision()) continue@queue\n                        hold(min(stepTime(), 100.0)) // cap time at 100sec\n                    }\n\n                    if(now &gt; maxDuration) break\n\n                    survivors.add(player)\n                }\n            }\n        }\n    }\n}\n</code></pre> <p>Move times are modeled using a log-normal distribution with the parameters from here. Similar to the previous work, we cap the time it takes a player to make a move (or just part of it) at 100 seconds.</p> <p>To get started, we can simply run the simulation with</p> <pre><code>val sim = SquidGame()\nsim.run()\n\nprintln(\"${sim.numSurvivors} survived\")\n</code></pre> <pre><code>5 survived\n</code></pre> <pre><code>sim.playerSurvived(13)\n</code></pre> <pre><code>true\n</code></pre> <pre><code>(1..18).map{ sim.playerSurvived(it)}\n</code></pre> <pre><code>[false, false, false, false, false, false, false, false, false, false, false, true, true, true, true, true, false, false]\n</code></pre> <p>The model seems fine at first glance. In particular, the impact of timing becomes visible, as the last player did not survive the game</p> <p>Some players survived the game. But clearly, running it once does not tell much about the average number of survivors. So we run it many times and visualize the distribution.</p> <pre><code>val manyGames = org.kalasim.misc.repeat(10000) {\n    SquidGame().apply { run() }\n}\n\nval avgSurvivors = manyGames.map { it.numSurvivors }.average()\nprintln(\"The average number of survivors is $avgSurvivors\")\n</code></pre> <pre><code>The average number of survivors is 5.436\n</code></pre> <p>Now since we have sampled the process, we can also easily visualize the survival count distribution</p> <pre><code>manyGames.plot(x = { numSurvivors }).geomBar().labs(\n    title = \"Outcomes of 10,000 trials\",\n    x = \"Number of survivors\",\n    y = \"Count\"\n)\n</code></pre> <p></p> <p>As we learn from the plot, we have obtained predominantly uni-modal distribution with an average of around 6 and minor zero-inflation. So on average 6 players will survive the game.</p>"},{"location":"examples/bridge_game/#maximize-survival","title":"Maximize Survival","text":"<p>To better understand the process, we want to visualize the probability of survival based on the player order number.</p> <pre><code>val survivalProbByNo = (1..manyGames.first().numPlayers).map { playerNo -&gt;\n    playerNo to manyGames.count { it.playerSurvived(playerNo) }.toDouble() / manyGames.size\n}\n\nsurvivalProbByNo.plot(x = { it.first }, y = { it.second }).geomCol().labs(\n    title = \"Probability of survival based on player order number\",\n    x = \"Player Order Number\",\n    y = \"Probability\"\n)\n</code></pre> <p></p> <p>So indeed there seems a strategy to maximize your odds of survival in the game. Simply pick No13, and you may live more likely compared to any other starting number.</p>"},{"location":"examples/bridge_game/#game-continuation","title":"Game Continuation","text":"<p>Now, we calculate the probability of having less than two survivors. That's in particular relevant in the series, as the bridge game is not meant to be the last game, and at least 2 players are required to continue the games.</p> <pre><code>val probLT2Players = manyGames.count { it.numSurvivors &lt; 2 }.toDouble() / manyGames.size\nprintln(\"The probability for less than 2 players is $probLT2Players\")\n</code></pre> <pre><code>The probability for less than 2 players is 0.0771\n</code></pre> <p>One may wonder why the makers of the series have placed 18 steps and not more or less? What do the numbers say? What are the odds for game continuation (# survivors &gt;2) when the number of steps is different?</p> <p>To answer these questions, let's re-run the model while varying the steps. To keep things simple, we run 10,000 iterations of the game over an increasing number of steps from 10 to 30:</p> <pre><code>val stepSims = (10..30).flatMap { numSteps -&gt;\n    org.kalasim.misc.repeat(10000) {\n        SquidGame(numSteps = numSteps).apply { run() }\n    }\n}\n\nval stepSimSummary = stepSims.groupBy { it.numSteps }.map { (steps, games) -&gt;\n    steps to games.count { it.numSurvivors &lt; 2 }.toDouble() / games.size\n}\n</code></pre> <pre><code>stepSimSummary.plot(x = { it.first }, y = { it.second }).geomCol().labs(\n    title = \"Probability of having less than two remaining players\",\n    x = \"Number of bridge steps\",\n    y = \"Probability\"\n)\n</code></pre> <p></p> <p>With more than 16 steps, the odds of having more than 2 players decay quickly.</p>"},{"location":"examples/bridge_game/#conclusion","title":"Conclusion","text":"<p>In this example we have explored a simple generative model. By means of simulation we have worked out an optimal strategy to survive the bridge game. But be reminded, if you ever find an invite to a squid-like game on your doorstep in times of despair , trash it, smoke it or eat it. There are better - and more fun - ways to make money, such as optimizing real-world processes with simulation and business intelligence.</p> <p>For complete sources, also see the jupyter notebook. Feel welcome to get in touch for support, suggestions, and questions.</p>"},{"location":"examples/callcenter/","title":"Call Center","text":"<p>Resource planning is the bread and butter of any successful business.</p> <p>Let's take a glimpse into the near future where kalasim has taken up a dominant role in the simulation industry. Hundreds of happy customers are utilizing the support hotline 24/7 from around the globe to obtain professional simulation assistance. Envision a customer service department, where a steady stream of customer requests come in, and the customer service agents are tasked with addressing these inquiries.</p> <p></p> <p> Call Center (\u00a9Plantronics, CC BY-SA 3.0) </p> <p>Choosing an appropriate shift model and planning shift capacity are key in this - and any successful - business operation. Due to the complex dynamics and interplay, it's often very challenging to determine capacity and pinpoint bottlenecks in such systems on paper.</p> <p>Here is how the envisioned call center functions:</p> <ul> <li>The requests arrive throughout the day and are queued and pooled, waiting for an available responder.</li> <li>The responders are available in two shifts, excluding weekends. Ideally, the two shifts should not have separate queues since there is already a pooled queue.</li> <li>If a responder from Shift A is working on a request but is about to end their shift, they will hand over the request they are working on to Shift B.</li> <li>Shifts A and B will have different capacities to mimic day/night shift regimes.</li> </ul> <p>Except for weekends, when there are no available shifts, the first available responder the following week will handle the unattended requests.</p> <p>To get started, let's initialize the environment by loading the latest version of kalasim:</p> <pre><code>@file:Repository(\"*mavenLocal\")\n\n%useLatestDescriptors on\n\n@file:DependsOn(\"com.github.holgerbrandl:kalasim:0.12-SNAPSHOT\")\n@file:DependsOn(\"com.github.holgerbrandl:kravis:0.9.95\")\n</code></pre>"},{"location":"examples/callcenter/#shift-system","title":"Shift System","text":"<p>To engineer a discrete event simulation for this particular business process, we begin by implementing the shift system. Technically, we use a sequence builder to create a weekly shift sequence that is repeated, allowing the subsequent model to run indefinitely.</p> <pre><code>enum class ShiftID { A, B, WeekEnd }\n\nval shiftModel = sequence {\n    while(true) {\n        repeat(5) { yield(ShiftID.A); yield(ShiftID.B) }\n        yield(ShiftID.WeekEnd)\n    }\n}\n</code></pre>"},{"location":"examples/callcenter/#customer-inquiries","title":"Customer Inquiries","text":"<p>Now, we model the customer requests as simulation entities. Each request is modelled as a <code>Component</code> with a dedicated small lifecycle where the call center agent is requested. The actual process time varies; it is exponentially distributed with an average of around 25 minutes.</p> <pre><code>class Request : Component() {\n    val callCenter = get&lt;Resource&gt;()\n\n    override fun process() = sequence {\n        request(callCenter, capacityLimitMode = CapacityLimitMode.SCHEDULE) {\n            hold(exponential(25.minutes).sample())\n        }\n    }\n}\n</code></pre>"},{"location":"examples/callcenter/#shift-manager","title":"Shift Manager","text":"<p>Next, we need to model the call center manager to modulate the shift (or in simulation speak resource) capacity dynamically.</p> <pre><code>class ShiftManager : Component() {\n    val shiftIt = shiftModel.iterator()\n    val callCenter = get&lt;Resource&gt;()\n\n    override fun repeatedProcess() = sequence {\n        val currentShift = shiftIt.next()\n\n        log(\"starting new shift ${currentShift}\")\n\n        // adjust shift capacity at the beginning of the shift\n        callCenter.capacity = when(currentShift) {\n            ShiftID.A -&gt; 2.0\n            ShiftID.B -&gt; 5.0\n            ShiftID.WeekEnd -&gt; 0.0\n        }\n\n        // wait for end of shift\n        hold(if(currentShift == ShiftID.WeekEnd) 48.hours else 12.hours)\n    }\n}\n</code></pre>"},{"location":"examples/callcenter/#simulation-environment","title":"Simulation Environment","text":"<p>Finally, we integrate everything into a simulation environment for easy experimentation. To facilitate convenient experimentation with various configurations and decision policies, we maintain the Shift Manager as an abstract entity, obliging the simulator to incorporate a specific implementation to conduct an experiment.</p> <pre><code>abstract class CallCenter(\n    val interArrivalRate: Duration = 10.minutes,\n    logEvents: Boolean = false\n) :\n    Environment(\n        enableComponentLogger = logEvents,\n        // note tick duration is just needed here to simplify visualization\n        tickDurationUnit = DurationUnit.HOURS\n    ) {\n\n    // intentionally not defined at this point\n    abstract val shiftManager: Component\n\n    val serviceAgents = dependency { Resource(\"Service Agents\") }\n\n    init {\n        ComponentGenerator(iat = exponential(interArrivalRate)) { Request() }\n    }\n}\n</code></pre> <p>Let's run the model for a month</p> <pre><code>val sim = object : CallCenter() {\n    override val shiftManager = ShiftManager()\n}\n\nsim.run(30.days)\n</code></pre> <p>To understand the dynamics of the model, we could now try inpspecting its progression. First we check out the queue length</p> <pre><code>sim.serviceAgents.requesters.queueLengthTimeline.display()\n</code></pre> <p></p> <p>What can we discern from this? Following an initial warm-up during the first week of January, there is a noticeable increase in requests accumulating over the weekend. These requests then undergo processing over the next five business days. While customers might experience a short wait, their requests are ultimately addressed. Therefore, based on queuing theory, the system is stable and does not result in an infinite queue length.</p>"},{"location":"examples/callcenter/#model-accuracy-during-shift-handover","title":"Model Accuracy During Shift Handover","text":"<p>Clearly, this first version has the limitation that tasks overlapping with a shift-change do not immediately respect changes in capacity. That is, when shifting from a highly-staffed shift to a lesser-staffed shift, ongoing tasks will be completed regardless of the reduced capacity.</p> <p>It's not straightforward to cancel these tasks and request them again in the next shift. This is because a <code>release()</code> will, by design, check if new requests could be served. So, ongoing tasks could be easily released, but re-requesting them - even with higher priority - would lead them to be processed slightly later than the requests that were immediately approved.</p> <p>To elegantly solve this problem, we can use two other methods - <code>interrupt()</code> and <code>standby()</code>. With <code>interrupt()</code>, we can stop all ongoing tasks at a shift change. With <code>standby()</code>, we can schedule process continuation in the next simulation cycle.</p> <p>For the revised model, we just need to create a different <code>ShiftManager</code> with our revised handover process:</p> <pre><code>class InterruptingShiftManager(\n    val aWorkers: Double = 2.0,\n    val bWorkers: Double = 5.0\n) : Component() {\n    val shiftIt = shiftModel.iterator()\n    val serviceAgents = get&lt;Resource&gt;()\n\n    override fun repeatedProcess() = sequence {\n        val currentShift = shiftIt.next()\n\n        log(\"starting new shift $currentShift\")\n\n        // adjust shift capacity at the beginning of the shift\n        serviceAgents.capacity = when(currentShift) {\n            ShiftID.A -&gt; aWorkers\n            ShiftID.B -&gt; bWorkers\n            ShiftID.WeekEnd -&gt; 0.0\n        }\n\n        // complete hangover calls from previous shift\n        fun shiftLegacy() = serviceAgents.claimers.components\n            .filter { it.isInterrupted }\n\n        // incrementally resume interrupted tasks while respecting new capacity\n        while(shiftLegacy().isNotEmpty() &amp;&amp; serviceAgents.capacity &gt; 0) {\n            val numRunning = serviceAgents.claimers.components\n                .count { it.isScheduled }\n            val spareCapacity = \n                max(0, serviceAgents.capacity.roundToInt() - numRunning)\n\n            // resume interrupted tasks from last shift to max out new capacity\n            shiftLegacy().take(spareCapacity).forEach { it.resume() }\n\n            standby()\n        }\n\n        // wait for end of shift\n        hold(if(currentShift == ShiftID.WeekEnd) 48.hours else 12.hours)\n\n        // stop and reschedule the ongoing tasks\n        serviceAgents.claimers.components.forEach {\n            // detect remaining task time and request this with high prio so\n            // that these tasks are picked up next in the upcoming shift\n            it.interrupt()\n        }\n    }\n}\n</code></pre> <p>We can now instantiate a new call center with the improved hand-over process</p> <pre><code>val intSim = object: CallCenter() {\n    override val shiftManager = InterruptingShiftManager()\n}\n\n// Let's run this model for a month\nintSim.run(180.days)\n</code></pre> <p>Again we study the request queue length as indicator for system stability:</p> <pre><code>intSim.serviceAgents.requesters.queueLengthTimeline\n    .display(\"Request queue length with revised handover process\")\n</code></pre> <p></p> <p>As we can see, the model is not stable. The number of support technicians is not adequate to serve the varying number of customers. Although the request frequency did not change, the more accurate shift transition modeling has impacted the result.</p> <p>To determine the correct sizing - i.e., the number of service operators needed to reliably serve customers - we will increase the day staff by one support technician and repeat the experiment.</p> <pre><code>val betterStaffed = object: CallCenter() {\n    override val shiftManager = InterruptingShiftManager(bWorkers = 6.0)\n}\n\nbetterStaffed.run(90.days)\n\n\nval queueLengthTimeline = betterStaffed.serviceAgents\n    .requesters.queueLengthTimeline\n\nqueueLengthTimeline.display(\"Request queue length with revised handover process\")\n</code></pre> <p></p> <p>Notably, this model has the almost the same dynamics, but is stable from a queuing perspective.</p>"},{"location":"examples/callcenter/#summary","title":"Summary","text":"<p>We have successfully modelled a variable shift length schedule and performed a sizing analysis. An initial model indicated that a weekday shift would be sufficiently staffed with 5 workers. However, a more detailed model, which also considers transition effects between shifts, led to the conclusion that 6 support technicians are required to serve the multitude of customers of Future Kalasim Inc.</p> <p>Could we have solved this more elegantly using the mathematics of queuing theory? Such models are a great starting point, but usually, they very quickly fail to deliver when realistic, non-stationary requirements are considered. That's when discrete event simulation can develop its beauty and potential. Flexible shift schedules are common in many industries, and the model introduced above could be easily adjusted to account for more business constraints and processes.</p> <p>The  use-case was adopted from the simmer mailing list</p>"},{"location":"examples/car/","title":"Car","text":"<p>A single car, a driver, and red traffic light in the middle of the night. </p> <p></p> <p> Red Light, Matthias Ripp (CC BY 2.0) </p> <p>Let\u2019s start with a very simple model. The example demonstrates the main mode of operation, the core API and the component process model implemented in <code>kalasim</code>. We want to build a simulation where a single car is driving around for a some time before stopping in front of a red traffic light.</p> <pre><code>////Cars.kts\nimport org.kalasim.*\nimport kotlin.time.Duration.Companion.hours\nimport kotlin.time.Duration.Companion.minutes\n\n\nclass Driver : Resource()\nclass TrafficLight : State&lt;String&gt;(\"red\")\n\nclass Car : Component() {\n\n    val trafficLight = get&lt;TrafficLight&gt;()\n    val driver = get&lt;Driver&gt;()\n\n    override fun process() = sequence {\n        request(driver) {\n            hold(30.minutes, description = \"driving\")\n\n            wait(trafficLight, \"green\")\n        }\n    }\n}\n\ncreateSimulation {\n    enableComponentLogger()\n\n    dependency { TrafficLight() }\n    dependency { Driver() }\n\n    Car()\n}.run(5.hours)\n</code></pre> <p>For each (active) component we (can) define a type such as:</p> <pre><code>class Car : Component()\n</code></pre> <p>The class inherits from <code>org.kalasim.Component</code>.</p> <p>Our car depends on a state <code>TrafficLight</code> and resource <code>Driver</code> for operation. To implement that, we first declare these dependencies with <code>dependency{}</code> in the main body of the simulation, and secondly inject them into our car with <code>get&lt;T&gt;</code>. Note, we could also directly inject states and resources with <code>dependency {State(\"red\")}</code> without sub-classing.</p> <p>Although it is possible to define other processes within a class, the standard way is to define a generator function called <code>process</code> in the class. A generator is a function that returns <code>Sequence&lt;Component&gt;</code>. Within these process definitions we use <code>suspend</code>able interaction function calls as a signal to give control to the centralized event loop.</p> <p>In this example,</p> <pre><code>hold(1.hour)\n</code></pre> <p>suspends execution control and comes back after 1 hour (of simulated time). Apart from <code>hold</code>, <code>kalasim</code> supports a rich vocabulary of interaction methods including <code>passivate</code>, <code>request</code>, <code>wait</code> and <code>component</code>.</p> <p>The main body of every <code>kalasim</code> model usually starts with: <pre><code>createSimulation{\n...\n}\n</code></pre> Here, we enable event logging of state changes to see the status of simulation on the console. After declaring our dependencies, we instantiate a single car with <code>Car()</code>. It automatically is assigned the name Car.0.</p> <p>As there is a generator function called <code>process</code> in <code>Car</code>, this process description will be activated (by default at time <code>now</code>, which is <code>0</code> by default at the beginning of a simulation). It is possible to start a process later, but this is by far the most common way to start a process.</p> <p>With</p> <pre><code>run(5.minutes)\n</code></pre> <p>we start the simulation and get back control after 5 simulated minutes. A component called main is defined under the hood to get access to the main process.</p> <p>When we run this program, we get the following output (displayed as table for convenience):</p> <pre><code>time   current  receiver  action                             info               \n------ -------- --------- ---------------------------------- -------------------\n.00             main      Created\n.00    main\n.00             Driver.1  Created                             capacity=1\n.00             Car.1     Created\n.00                       activate                           scheduled for .00\n.00             main      run +5.00                          scheduled for 5.00\n.00    Car.1    Car.1\n.00                       Requesting 1.0 from Driver.1 \n.00                       Claimed 1.0 from 'Car.1'\n.00                       Request honor Driver.1             scheduled for .00\n.00\n.00                       hold +1.00                         scheduled for 1.00\n1.00\n1.00                      entering waiters of TrafficLight.1\n1.00                      wait                               scheduled for &lt;inf&gt;\n5.00   main     main\nProcess finished with exit code 0\n</code></pre> <p>There are plenty of other more advanced (that is more fun!) examples listed in examples chapter.</p>"},{"location":"examples/car_wash/","title":"Car Wash","text":"<p>In this example, we'll learn how to wait for resources. The example is adopted from the SimPy example.</p> <p>We simulate a carwash with a limited number of machines and a number of cars that arrive at the carwash to get cleaned. The carwash uses a resource to model the limited number of washing machines. It also defines a process for washing a car.</p> <p>When a car arrives at the carwash, it requests a machine. Once it got one, it starts the carwash\u2019s wash processes and waits for it to finish. It finally releases the machine and leaves.</p> <p>The cars are generated by a setup process. After creating an initial amount of cars it creates new car processes after a random time interval as long as the simulation continues.</p> <pre><code>////CarWash.kt\nimport org.kalasim.*\nimport kotlin.time.Duration.Companion.days\nimport kotlin.time.Duration.Companion.minutes\n\n/**\n *  A carwash has a limited number of washing machines and defines\n * a washing processes that takes some (random) time.\n *\n * Car processes arrive at the carwash at a random time. If one washing\n * machine is available, they start the washing process and wait for it\n * to finish. If not, they wait until they an use one.\n */\nfun main() {\n\n    val RANDOM_SEED = 42\n    val NUM_MACHINES = 2  // Number of machines in the carwash\n    val WASHTIME = 5.minutes      // Minutes it takes to clean a car\n    val T_INTER = 7.minutes       // Create a car every ~7 minutes\n    val T_INTER_SD = 2.minutes       // variance of inter-arrival\n    val SIM_TIME = 20.days     // Simulation time\n\n    class Car : Component() {\n        override fun process() = sequence {\n            val carWash = get&lt;Resource&gt;()\n            request(carWash)\n            hold(WASHTIME)\n            release(carWash)\n        }\n    }\n\n\n    val env = createSimulation(randomSeed = RANDOM_SEED) {\n        dependency { Resource(\"carwash\", NUM_MACHINES) }\n\n        enableComponentLogger()\n\n        //Create 4 initial cars\n        repeat(3) { Car() }\n        // Create more cars while the simulation is running\n        ComponentGenerator(iat = uniform(T_INTER - T_INTER_SD, T_INTER + T_INTER_SD)) { Car() }\n    }\n\n\n    println(\"Carwash\\n======\\n\")\n    println(\"Check out http://youtu.be/fXXmeP9TvBg while simulating ... ;-)\")\n\n    // Start the simulation\n    env.run(SIM_TIME)\n}\n</code></pre>"},{"location":"examples/dining_philosophers/","title":"Dining Philosophers","text":"<p>The Dining Philosophers problem is a classical example in computer science to illustrate synchronisation issues in concurrent processes. It was originally formulated in 1965 by E. W. Dijkstra as a student exam exercise, and was later reworked in its current form by Tony Hoare:</p> <p>Some philosophers sit at a round table with bowls of spaghetti with tomato sauce and tasty cheese. Forks are placed between each pair of adjacent philosophers.</p> <p>Each philosopher must alternately think and eat. However, a philosopher can only eat spaghetti when they have both left and right forks. Each fork can be held by only one philosopher and so a philosopher can use the fork only if it is not being used by another philosopher. After an individual philosopher finishes eating, they need to put down both forks so that the forks become available to others. A philosopher can take the fork on their right or the one on their left as they become available, but cannot start eating before getting both forks.</p> <p></p> <p>The problem is how to design a discipline of behavior (a concurrent algorithm) such that no philosopher will starve; i.e., each can forever continue to alternate between eating and thinking, assuming no philosopher can know when others may want to eat or think.</p>"},{"location":"examples/dining_philosophers/#simulation","title":"Simulation","text":"<p>Let us define each philosopher as a process executing a thinking + eating loop, and acting concurrently on shared resources (the forks). Each process will follow a similar trajectory in which they</p> <ol> <li>Spend some random time thinking until they become hungry.</li> <li>Take one fork, when available, following a given policy.</li> <li>After some lag, take the other fork, when available.</li> <li>Spend some random time eating.</li> <li>Put both forks down and go back to 1.</li> </ol> <p>The following function sets up a simulation of $N$ dining philosophers as established above:</p> <pre><code>//\n</code></pre> <p>To enable a strictly typed simulation, we declare the resource <code>Fork</code> and component <code>Philosopher</code>. The latter is associated to a process where the philosopher first thinks for some exponentially distributed time, takes a fork, meditates for a brief second, and finally takes the second fork once it becomes available. Both interactions modelled as requests where we use a self-releasing request context. Once the philosopher has eaten, the whole process starts over again.</p> <p>A variable number of philosophers (here N=4) is instantiated and are equipped with forks on their left and right.</p> <p>Our implementation follows the solution originally proposed by Dijkstra, which establishes the convention that all resources must be requested in order. This means that, in our simulation, Aristotle should pick fork 1 first instead. Without that convention, the simulation would stop soon at a point in which every philosopher holds one fork and waits for the other to be available.</p> <p>Finally, we can transform the resulting monitoring data with <code>krangl</code> and visualize it with <code>kravis</code>.</p> <p></p> <p>See here for a jupyter notebook implementation of this example.</p> <p>This example was adopted from the simmer manual.</p>"},{"location":"examples/emergency_room/","title":"Emergency Room","text":"<p>Everyone is enjoying the summer, Covid19 restrictions have been lifted, we all get back to regular exercise and outdoor activities. But once in a while, the inevitable happens: An ill-considered step, a brief second of inattention, and injuries all of all types will happen, that require immediate treatment. Luckily our city hosts a modern hospital with an efficient emergency room where the wounded are being taken care of.</p> <p>To save more lives, the mayor has asked us to review and potentially improve process efficiency in the ER. To do so, we need to realize the following steps</p> <ol> <li>Understand the current process and model is as simulation</li> <li>Formulate key objectives to be optimized</li> <li>Assess process statistics and metrics, to unravel potential improvements to help more patients.</li> <li>Explore more optimized decision policies to increase </li> </ol> <p>So let's dive right into it without further ado. </p>"},{"location":"examples/emergency_room/#process-model","title":"Process Model","text":"<p>Patients are classified two-fold 1. By Severity. The ER is using the well known Emergency Severity Index to triage patients based on the acuity of patients' health care problems, and the number of resources their care is anticipated to require.  2. Type of injury which are defined here</p> <p>Resources</p> <ul> <li>Surgery rooms that must be   equipped by considering the type (i.e., the family) of surgery to   be performed. It will take time to prepare a room for a certain type of injury. These setup times are listed in an excel sheet.</li> <li>Doctors that are qualified for a subset of all possible injuries</li> </ul> <p>Process dynamics</p> <ul> <li>PD-A Depending on the severity, patients might die if not being treated. Also, if not being treated their severity will increase rather quickly</li> <li>PD-B The more busy the waiting room is, the less efficient surgeries tend to be. This is because of stress (over-allocation of supporting personal and material). It is phenomenon that is often observed complex queuing processes such as manufacturing or customer services.  </li> <li>PD-C Depending on the severity, patients will die during surgery</li> <li>PD-D The surgery time correlates with the severity of the injury</li> <li>PD-E During nights fewer new patients arrive compared to the day</li> </ul> <p>Clearly, more resources are required in the ER and many supported processes are required to run it. However, we leave these out here, as they are not considered to have a major impact on the overall process efficiency. Choosing a correct level of abstraction with a focus on key actors and resources, is the first key to success when optimizing a complex process.</p>"},{"location":"examples/emergency_room/#implementation","title":"Implementation","text":"<p>The tick-unit of the simulation is hours.</p>"},{"location":"examples/emergency_room/#key-objectives-observations","title":"Key Objectives &amp; Observations","text":"<p>The head nurse, who is governing the process based on her long-term experience, is scheduling patients based on the following principle</p> <p>Most urgent injuries first</p> <p>Clearly if possible it would be great to also * Minimize waiting times * Reduce number of surgery room setups</p>"},{"location":"examples/emergency_room/#analysis","title":"Analysis","text":"<p>Because of the great variety rooms, we observe a lot of setup steps to prepare surgery rooms. Often even if patients with the same type of injury all already waiting.</p>"},{"location":"examples/emergency_room/#process-optimization","title":"Process Optimization","text":"<p>The idea for model above was orginally formulated by Kramer et al. in 2019 : </p> <p>Other relevant applications arise in the context of health-care, where, for example, patients have to be assigned to surgery rooms that must be equipped by considering the type (i.e., the family) of surgery to be performed. In such cases, the weight usually models a level of urgency for the patient. */</p>"},{"location":"examples/emergency_room/#conclusion-summary","title":"Conclusion &amp; Summary","text":"<p>In this article we have worked out a complex process with partially non-intuitive process dynamics can be modelled with kalasim and optimized using insights from operations research.</p> <p>Disclaimer: The author is not a medical doctor, so please excuse possible inprecsion in wording and lack of ER process understanding. Feel welcome to suggest corrections or improvements</p>"},{"location":"examples/ferryman/","title":"The Ferryman","text":"<p>A wild river, one boat only, and a patient ferryman transporting batches of passengers across the body of water.</p> <p>Covers:</p> <ul> <li>Batching to consume queue elements in defined blocks</li> <li>Monitors for stats and visualization</li> </ul> <p></p> <p> Stanhope Forbes - A Ferryman at Flushing (oil on canvas, CC0 1.0) </p>"},{"location":"examples/ferryman/#simulation","title":"Simulation","text":"<p>To form groups of passengers before passing the waters, we use <code>batch()</code> in the ferryman's process definition. It has multiple arguments:</p> <ul> <li>A mandatory queue with elements of type <code>&lt;T&gt;</code> to be consumed</li> <li>The size of the batch to be created. A positive integer is expected here.</li> <li>An optional timeout describing how long it shall wait before forming an incomplete/empty batch</li> </ul> <p><code>batch</code> will return a list of type <code>&lt;T&gt;</code> of size <code>batchSize</code> or lesser (and potentially even empty) if timed out before filling the batch.</p> <pre><code>////Ferryman.kts\npackage org.kalasim.examples\n\nimport org.kalasim.*\nimport org.kalasim.monitors.NumericStatisticMonitor\nimport org.kalasim.plot.kravis.display\nimport kotlin.time.Duration.Companion.minutes\n\ncreateSimulation {\n\n    class Passenger : Component()\n\n    val fm = object : Component(\"ferryman\") {\n        val left2Right = ComponentQueue&lt;Passenger&gt;()\n        val right2Left = ComponentQueue&lt;Passenger&gt;()\n\n        val l2rMonitor = NumericStatisticMonitor()\n        val r2lMonitor = NumericStatisticMonitor()\n\n        override fun process() = sequence {\n            val batchLR: List&lt;Passenger&gt; = batch(left2Right, 4, timeout = 10.minutes)\n            l2rMonitor.addValue(batchLR.size)\n            hold(5.minutes, description = \"shipping ${batchLR.size} l2r\")\n\n            val batchRL: List&lt;Passenger&gt; = batch(right2Left, 4, timeout = 10.minutes)\n            r2lMonitor.addValue(batchRL.size)\n            hold(5.minutes, description = \"shipping ${batchRL.size} r2l\")\n\n            // we could also use an infinite while loop instead of activate\n            activate(process = Component::process)\n        }\n    }\n\n    ComponentGenerator(uniform(0, 15).minutes) { Passenger() }\n        .addConsumer { fm.left2Right.add(it) }\n\n    ComponentGenerator(uniform(0, 12).minutes) { Passenger() }\n        .addConsumer { fm.right2Left.add(it) }\n\n    run(10000.minutes)\n\n    fm.l2rMonitor.display(\"Passengers left-&gt;right\")\n    fm.r2lMonitor.display(\"Passengers right-&gt;left\")\n}\n</code></pre>"},{"location":"examples/ferryman/#analysis","title":"Analysis","text":"<p>The ferryman tries to max out his boat with 4 passengers, but after 10 minutes he will start anyway (even if the boat is entirely emtpy). <code>kalasim</code> will suspend execution when using <code>batch()</code> until <code>timeout</code> or indefinitely (if <code>timeout</code> is not set).</p> <p>Since both banks have different arrival distributions, we observe different batch-size patterns:</p> <p>Right\u2192Left</p> <p>Since passengers on the right bank arrive with a higher rate (that is shorter inter-arrival time between <code>0</code> and <code>12</code>), the ferry is usually packed with people. Only occasionally the ferryman traverses from left to right banks with less than 4 passengers.</p> <p></p> <p>Left\u2192Right</p> <p>Because of a slightly higher inter-arrival time (up to <code>15</code> minutes) on the left banks, it often happens that the ferry starts its journey across the river with some seats unoccupied. On average, just <code>3</code> seats are taken. However, at least during this simulation we did not encounter a passing with just the ferryman and his thoughts.</p> <p></p>"},{"location":"examples/gas_station/","title":"Gas Station","text":"<p>This example models a gas station and cars that arrive at the station for refueling.</p> <p>Covers:</p> <ul> <li>Depletable Resources</li> <li>Process Interaction, in particular waiting for other processes</li> </ul> <p>The gas station has a limited number of fuel pumps, and a fuel tank that is shared between the fuel pumps. The gas pumps are modeled as <code>Resource</code>. The shared fuel tank is modeled with a <code>DepletableResource</code>.</p> <p></p> <p> Vintage Gas Pump, (CCO 1.0) </p> <p>Vehicles arriving at the gas station first request a fuel pump from the station. Once they acquire one, they try to take the desired amount of fuel from the fuel pump. They leave when they are done.</p> <p>The gas stations fuel level is regularly monitored by gas station control. When the level drops below a certain threshold, a tank truck is called to refuel the gas station itself.</p> <p>The example is a true classic and its implementation below was adopted from salabim's and SimPy's gas stations.</p> <p>To begin with, we declare required dependencies. Only kalasim (for obvious reasons) and kravis (for visualization) are needed here.</p> <pre><code>//@file:Repository(\"*mavenLocal\")\n//@file:DependsOn(\"com.github.holgerbrandl:kalasim:0.7-SNAPSHOT\")\n\n// TODO Update to v0.8\n@file:DependsOn(\"com.github.holgerbrandl:kalasim:0.7.90\")\n@file:DependsOn(\"com.github.holgerbrandl:kravis:0.8.1\")\n</code></pre> <p>Next, we import required classes.</p> <pre><code>import org.kalasim.*\nimport org.kalasim.monitors.printHistogram\nimport org.koin.core.component.inject\nimport org.koin.core.qualifier.named\n</code></pre> <p>Define configuration and constants to be use in simulation model are grouped into a dedicated section.</p> <pre><code>val GAS_STATION_SIZE = 200.0  // liters\nval THRESHOLD = 25.0  // Threshold for calling the tank truck (in %)\nval FUEL_TANK_SIZE = 50.0  // liters\nval FUEL_TANK_LEVEL_RANGE = 5.. 25\nval REFUELING_SPEED = 2.0  // liters / second\nval TANK_TRUCK_TIME = 300.0  // Seconds it takes the tank truck to arrive\nval INTER_ARRIVAL_TIME_RANGE = 10..100  // Create a car every [min, max] seconds\nval SIM_TIME = 20000.0  // Simulation time in seconds\n</code></pre> <p>Now, we implement the domain model by detailing out the lifecycle processes of the cars and the gasoline trucks.</p> <pre><code>val FUEL_TANK = \"fuel_pump\"\n\n/** Arrives at the gas station after a certain delay and refuels it.*/\nclass TankTruck : Component() {\n    val fuelPump: DepletableResource by inject(qualifier = named(FUEL_TANK))\n\n    val unloaded = State(false)\n\n    override fun process() = sequence {\n        hold(TANK_TRUCK_TIME)\n\n        // fill but cap when tank is full\n//        put(fuelPump, quantity = GAS_STATION_SIZE, capacityLimitMode = CapacityLimitMode.CAP)\n\n        // same effect, but different approach is to refill the missing quantity\n        put(fuelPump, quantity = fuelPump.capacity - fuelPump.level)\n        unloaded.value = true\n    }\n}\n\n/** A car arrives at the gas station for refueling.\n*\n* It requests one of the gas station's fuel pumps and tries to get the\n* desired amount of gas from it. If the stations reservoir is\n* depleted, the car has to wait for the tank truck to arrive.\n*/\nclass Car(\n    val tankSize: Double = FUEL_TANK_SIZE,\n) : Component() {\n\n    // Sample an initial level\n    val fuelTankLevel = discreteUniform(FUEL_TANK_LEVEL_RANGE)()\n\n    // Resolve dependencies\n    val fuelPump = get&lt;Resource&gt;()\n    val stationTank: DepletableResource by inject(qualifier = named(FUEL_TANK))\n\n    override fun process() = sequence {\n        request(fuelPump, description = \"waiting for free pump\") {\n            val litersRequired = tankSize - fuelTankLevel\n\n            take(stationTank, quantity = litersRequired)\n            hold(litersRequired / REFUELING_SPEED)\n            println(\"finished $name\")\n        }\n    }\n}\n</code></pre> <p>To conclude the implementation, we bind domain entities into simulation environment. To do so we add a component generator to provide new customers, and a anonymous component to realize a control process that will order a new tank-trunk if the station starts running low on gasoline supply.</p> <pre><code>class GasStation : Environment(false) {\n    val tank = dependency(qualifier = named(FUEL_TANK)) { DepletableResource(FUEL_TANK, GAS_STATION_SIZE) }\n\n    val fuelPumps = dependency { Resource(capacity = 2) }\n\n    init {\n        // Generate new cars that arrive at the gas station.\n        ComponentGenerator(iat = with(INTER_ARRIVAL_TIME_RANGE) { uniform(first, last) }) { Car() }\n\n        //Periodically check the level of the *fuel_pump* and call the tank truck if the level falls below a threshold.\n        object : Component(\"gas_station_control\") {\n            override fun repeatedProcess() = sequence {\n                // Order a new truck if the fuel-pump runs of out fuel\n                if(tank.level / tank.capacity * 100 &lt; THRESHOLD) {\n                    log(\"Running out of fuel (remaining ${tank.level}). Ordering new fuel truck...\")\n                    wait(TankTruck().unloaded, true)\n                }\n\n                hold(10) // check every 10 seconds\n            }\n        }\n    }\n}\n</code></pre> <pre><code>Back-end (JVM) Internal error: Failed to generate expression: KtNameReferenceExpression\nFile being compiled: (2,45) in Line_6.jupyter-kts\nThe root cause java.lang.UnsupportedOperationException was thrown at: org.jetbrains.kotlin.codegen.context.ConstructorContext.getOuterExpression(ConstructorContext.java:65)\n</code></pre> <p>Note: This is currently broken until https://github.com/Kotlin/kotlin-jupyter/issues/126 becomes fixed.</p> <p>Here,  we use both lazy injection with <code>inject&lt;T&gt;()</code> and instance retrieval with <code>get&lt;T&gt;()</code>. For details see koin reference</p> <p>Let's run the simulation</p> <pre><code>val gasStation = GasStation()\n\ngasStation.run(SIM_TIME)\n</code></pre> <pre><code>Line_6$GasStation\n\njava.lang.NoClassDefFoundError: Line_6$GasStation\n\n    at Line_7.&lt;init&gt;(Line_7.jupyter-kts:1)\n\n    at java.base/jdk.internal.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)\n\n    at java.base/jdk.internal.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:62)\n\n    at java.base/jdk.internal.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)\n\n    at java.base/java.lang.reflect.Constructor.newInstance(Constructor.java:490)\n\n    at kotlin.script.experimental.jvm.BasicJvmScriptEvaluator.evalWithConfigAndOtherScriptsResults(BasicJvmScriptEvaluator.kt:100)\n\n    at kotlin.script.experimental.jvm.BasicJvmScriptEvaluator.invoke$suspendImpl(BasicJvmScriptEvaluator.kt:47)\n\n    at kotlin.script.experimental.jvm.BasicJvmScriptEvaluator.invoke(BasicJvmScriptEvaluator.kt)\n\n    at kotlin.script.experimental.jvm.BasicJvmReplEvaluator.eval(BasicJvmReplEvaluator.kt:49)\n\n    at org.jetbrains.kotlinx.jupyter.repl.impl.InternalEvaluatorImpl$eval$resultWithDiagnostics$1.invokeSuspend(InternalEvaluatorImpl.kt:99)\n\n    at kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith(ContinuationImpl.kt:33)\n\n    at kotlinx.coroutines.DispatchedTask.run(DispatchedTask.kt:106)\n\n    at kotlinx.coroutines.EventLoopImplBase.processNextEvent(EventLoop.common.kt:274)\n\n    at kotlinx.coroutines.BlockingCoroutine.joinBlocking(Builders.kt:85)\n\n    at kotlinx.coroutines.BuildersKt__BuildersKt.runBlocking(Builders.kt:59)\n\n    at kotlinx.coroutines.BuildersKt.runBlocking(Unknown Source)\n\n    at kotlinx.coroutines.BuildersKt__BuildersKt.runBlocking$default(Builders.kt:38)\n\n    at kotlinx.coroutines.BuildersKt.runBlocking$default(Unknown Source)\n\n    at org.jetbrains.kotlinx.jupyter.repl.impl.InternalEvaluatorImpl.eval(InternalEvaluatorImpl.kt:99)\n\n    at org.jetbrains.kotlinx.jupyter.repl.impl.CellExecutorImpl$execute$1$result$1.invoke(CellExecutorImpl.kt:64)\n\n    at org.jetbrains.kotlinx.jupyter.repl.impl.CellExecutorImpl$execute$1$result$1.invoke(CellExecutorImpl.kt:63)\n\n    at org.jetbrains.kotlinx.jupyter.ReplForJupyterImpl.withHost(repl.kt:603)\n\n    at org.jetbrains.kotlinx.jupyter.repl.impl.CellExecutorImpl.execute(CellExecutorImpl.kt:63)\n\n    at org.jetbrains.kotlinx.jupyter.repl.CellExecutor$DefaultImpls.execute$default(CellExecutor.kt:13)\n\n    at org.jetbrains.kotlinx.jupyter.ReplForJupyterImpl$evalEx$1.invoke(repl.kt:423)\n\n    at org.jetbrains.kotlinx.jupyter.ReplForJupyterImpl$evalEx$1.invoke(repl.kt:412)\n\n    at org.jetbrains.kotlinx.jupyter.ReplForJupyterImpl.withEvalContext(repl.kt:376)\n\n    at org.jetbrains.kotlinx.jupyter.ReplForJupyterImpl.evalEx(repl.kt:412)\n\n    at org.jetbrains.kotlinx.jupyter.ReplForJupyterImpl.eval(repl.kt:460)\n\n    at org.jetbrains.kotlinx.jupyter.ProtocolKt$shellMessagesHandler$res$1.invoke(protocol.kt:291)\n\n    at org.jetbrains.kotlinx.jupyter.ProtocolKt$shellMessagesHandler$res$1.invoke(protocol.kt:290)\n\n    at org.jetbrains.kotlinx.jupyter.JupyterConnection$runExecution$execThread$1.invoke(connection.kt:166)\n\n    at org.jetbrains.kotlinx.jupyter.JupyterConnection$runExecution$execThread$1.invoke(connection.kt:164)\n\n    at kotlin.concurrent.ThreadsKt$thread$thread$1.run(Thread.kt:30)\n</code></pre> <p>Analyze the dynamics of the model</p> <pre><code>// or accessor\nval tank = gasStation.tank\n\n// print some stats\ntank.levelTimeline.printHistogram()\n\ntank.levelTimeline.display().show()\n</code></pre> <p>Also inspect if the gas station is equipped with enough gas pumps to serve customers</p> <pre><code>gasStation.fuelPumps.claimedTimeline.display()\n</code></pre> <pre><code>Line_9.jupyter-kts (1:1 - 11) Unresolved reference: gasStation\n</code></pre>"},{"location":"examples/gas_station/#conclusion","title":"Conclusion","text":"<p>In this example we have explored how a depletable resource can be consumed by multipler clients.</p>"},{"location":"examples/machine_parts/","title":"Machine Parts","text":"<p>This model demonstrates the use of stacked interrupts. It is adopted from here.</p> <p>Each of two machines has three parts, that will be subject to failure. If one or more of these parts has failed, the machine is stopped. Only when all parts are operational, the machine can continue its work (hold).</p> <p>For a machine to work it needs the resource. If, during the requesting of this resource, one or more parts of that machine break down, the machine stops requesting until all parts are operational.</p> <p>In this model the interrupt level frequently gets to 2 or 3 (all parts broken down).</p> <p>Have a close look at the trace output to see what is going on.</p> <pre><code>////MachineWithParts.kt\nimport org.kalasim.*\nimport kotlin.time.Duration.Companion.hours\nimport kotlin.time.Duration.Companion.minutes\n\nclass Part(val machine: Machine, partNo: Int) :\n    Component(\n        name = machine.name.replace(\"Machine\", \"part\") + \".${partNo + 1}\"\n    ) {\n\n    val ttf = uniform(19.hours, 20.hours) // time to failure distribution\n    val ttr = uniform(3.hours, 6.hours)  //  time to repair distribution\n\n    override fun process() = sequence {\n        while(true) {\n            hold(ttf())\n            machine.interrupt()\n            hold(ttr())\n            machine.resume()\n        }\n    }\n}\n\n\nclass Machine : Component() {\n\n    init {\n        repeat(3) { Part(this, it) }\n    }\n\n    override fun process() = sequence {\n        while(true) {\n            val r = get&lt;Resource&gt;()\n            request(r)\n            hold(5.minutes)\n            release(r)\n        }\n    }\n}\n\nfun main() {\n    createSimulation {\n        enableComponentLogger()\n\n        dependency { Resource() }\n        repeat(2) { Machine() }\n\n        run(400.hours)\n    }\n}\n</code></pre>"},{"location":"examples/machine_shop/","title":"Machine Shop","text":"<p>In this example, we'll learn how to interrupt a process because of more important tasks. The example is adopted from the SimPy Machine Shop Example.</p> <p>The example covers interrupt and preemptive resources.</p> <p>The example comprises a workshop with <code>n</code> identical machines. A stream of jobs (enough to keep the machines busy) arrives. Each machine breaks down periodically. Repairs are carried out by one repairman. The repairman has other, less important tasks to perform, too. Broken machines preempt these tasks. The repairman continues them when he is done with the machine repair. The workshop works continuously.</p> <p>A machine has two processes:</p> <ol> <li>working implements the actual behaviour of the machine (producing parts).</li> <li>break_machine  periodically interrupts the working process to simulate the machine failure.</li> </ol> <p>In <code>kalasim</code> there can only be one generating process per component. So to model the wear, we use a separate <code>MachineWear</code> which is <code>interrupt</code>ing the machine in case of failure.</p> <p>The repairman\u2019s other job is also a process (implemented by otherJob). The repairman itself is a preemptive resource with a capacity of <code>1</code>. The machine repairing has a priority of 1, while the other job has a priority of <code>2</code> (the smaller the number, the higher the priority).</p> <pre><code>////MachineShop.kt\nimport org.kalasim.*\nimport kotlin.time.Duration.Companion.days\nimport kotlin.time.Duration.Companion.minutes\n\n\nval RANDOM_SEED: Int = 42\nval PT_MEAN = 10.minutes // Avg. processing time in minutes\nval PT_SIGMA = 2.minutes // Sigma of processing time\nval MTTF = 300.minutes // Mean time to failure in minutes\nval REPAIR_TIME = 30.minutes // Time it takes to repair a machine in minutes\nval JOB_DURATION = 30.minutes // Duration of other jobs in minutes\nval NUM_MACHINES: Int = 10   // Number of machines in the machine shop\nval SIM_TIME = 28.days  // Simulation time\n\nfun main() {\n\n    class Machine : Component() {\n        var madeParts: Int = 0\n            private set\n\n        val timePerPart: DurationDistribution = normal(PT_MEAN, PT_SIGMA)\n\n        override fun process(): Sequence&lt;Component&gt; = sequence {\n            while(true) {\n                // start working on a new part\n                log(\"building a new part\")\n                hold(timePerPart())\n                log(\"finished building part\")\n                madeParts++\n            }\n        }\n    }\n\n\n    /** Break the machine every now and then. */\n    class MachineWear(val machine: Machine, val repairMan: Resource) : Component(\n        process = MachineWear::breakMachine\n    ) {\n\n\n        fun breakMachine(): Sequence&lt;Component&gt; = sequence {\n            val timeToFailure = exponential(MTTF)\n\n            while(true) {\n                hold(timeToFailure())\n\n                // handle the rare case that the model\n                if(machine.isInterrupted) continue\n\n                machine.interrupt()\n\n                request(repairMan)\n                hold(REPAIR_TIME)\n\n                require(!isBumped(repairMan)) { \"productive tools must not be bumped\" }\n\n                release(repairMan)\n\n                machine.resume()\n                require(!machine.isInterrupted) { \"machine must not be interrupted at end of wear cycle\" }\n            }\n        }\n    }\n\n\n    createSimulation(randomSeed = RANDOM_SEED) {\n        enableComponentLogger()\n\n        val repairMan = Resource(\"mechanic\", preemptive = true)\n\n\n        // create N machines and wear components\n        val tools = (1..NUM_MACHINES).map {\n            Machine().also { MachineWear(it, repairMan) }\n        }\n\n        // define the other jobs as object expression\n        // https://kotlinlang.org/docs/reference/object-declarations.html#object-expressions\n        object : Component(\"side jobs\") {\n            override fun process() = sequence {\n                while(true) {\n                    request(ResourceRequest(repairMan, priority = Priority(-1)))\n                    hold(JOB_DURATION)\n\n                    if(isBumped(repairMan)) {\n                        log(\"other job was bumped\")\n                        continue\n                    }\n\n                    release(repairMan)\n                }\n            }\n        }\n\n        // Run simulation\n        run(1000.minutes)\n        run(SIM_TIME)\n\n        // Analysis\n\n        tools.forEach { println(\"${it.name} made ${it.madeParts} parts.\") }\n    }\n}\n</code></pre>"},{"location":"examples/movie_theater/","title":"Movie Theater","text":"<p>Covers:</p> <ul> <li>Resources</li> <li>Event operators</li> <li>Shared events</li> </ul> <p>This example models a movie theater with one ticket counter selling tickets for three movies (next show only). People arrive at random times and try to buy a random number (1\u20136) tickets for a random movie. When a movie is sold out, all people waiting to buy a ticket for that movie renege (leave the queue).</p> <p>The movie theater is just a type to assemble all the related data (movies, the counter, tickets left, collected data, ...). The counter is a Resource with a capacity of one.</p> <p>The moviegoer process function starts waiting until either it\u2019s his turn (it acquires the counter resource) or until the sold out signal is triggered. If the latter is the case it reneges (leaves the queue). If it gets to the counter, it tries to buy some tickets. This might not be successful, e.g. if the process tries to buy 5 tickets but only 3 are left. If less than two tickets are left after the ticket purchase, the sold out signal is triggered.</p> <p>Moviegoers are generated by the customer arrivals process. It also chooses a movie, and the number of tickets for the moviegoer.</p> <pre><code>////MovieRenege.kt\nimport org.kalasim.*\nimport org.kalasim.misc.roundAny\nimport kotlin.time.Duration.Companion.minutes\n\nfun main() {\n\n    val RANDOM_SEED = 158\n    val TICKETS = 50  // Number of tickets per movie\n    val SIM_TIME = 120.minutes  // Simulate until\n\n    data class Movie(val name: String)\n\n    val MOVIES = listOf(\"Julia Unchained\", \"Kill Process\", \"Pulp Implementation\").map { Movie(it) }\n\n    createSimulation(randomSeed = RANDOM_SEED) {\n        enableComponentLogger()\n\n        // note: it's not really needed to model the theater (because it has no process), but we follow the julia model here\n        val theater = object {\n            val tickets =\n                MOVIES.associateWith { DepletableResource(\"room ${MOVIES.indexOf(it)}\", capacity = TICKETS) }\n            val numReneged = MOVIES.associateWith { 0 }.toMutableMap()\n            val counter = Resource(\"counter\", capacity = 1)\n        }\n\n        class Cineast(val movie: Movie, val numTickets: Int) : Component() {\n            override fun process() = sequence {\n                request(theater.counter) {\n                    request(theater.tickets[movie]!! withQuantity numTickets, failAt = 0.simTime)\n                    if(failed) {\n                        theater.numReneged.merge(movie, 1, Int::plus)\n                    }\n                }\n            }\n        }\n\n        ComponentGenerator(iat = exponential(0.5.minutes)) {\n            Cineast(MOVIES.random(), discreteUniform(1, 6).sample())\n        }\n\n        run(SIM_TIME)\n\n        MOVIES.forEach { movie -&gt;\n            val numLeftQueue = theater.numReneged[movie]!!\n            val soldOutSince = theater.tickets[movie]!!.occupancyTimeline.stepFun()\n                // find the first time when tickets were sold out\n                .first { it.value == 1.0 }.time.toTickTime().value.roundAny(2)\n\n            println(\"Movie ${movie.name} sold out $soldOutSince minutes after ticket counter opening.\")\n            println(\"$numLeftQueue walked away after film was sold out.\")\n        }\n\n//        // Visualize ticket sales\n//        val plotData = theater.tickets.values.flatMap {\n//            it.occupancyTimeline.stepFun().map { sf -&gt; Triple(it.name, sf.first, sf.second) }\n//        }\n//\n//        plotData.toDataFrame().plot(x = \"second\", y = \"third\")\n//            .geomStep().facetWrap(\"first\").title(\"Theater Occupancy\")\n//            .xLabel(\"Time (min)\").yLabel(\"Occupancy\")\n    }\n}\n</code></pre> <p>The example also details out how we could now easily plot the occupancy progressions using automatically captured monitoring data.</p> <p></p> <p>Adopted from SimJulia example.</p>"},{"location":"examples/office_tower/","title":"Office Tower","text":"<p>In this logistics model, we simulate an office tower. There are N lifts with capacity limited cars. Passengers arrive at different floors with different rates and press buttons indicating the direction of their target floor. The cars have a defined speed, and clearly it takes time to open/close its doors before passengers can enter &amp; leave.</p> <p></p> <p>Parameters</p> <ul> <li>Origin/destination distribution of visitors</li> <li>Number of elevators</li> <li>Capacity of each elevator</li> <li>Number of floors</li> <li>Times for moving between floors, for opening/closing doors, and for passenger to move or out a car</li> </ul>"},{"location":"examples/office_tower/#implementation","title":"Implementation","text":"<p>See <code>Elevator.kt</code> for the implementation.</p> <p>The implementation is adopted from salabim's elevator example.</p>"},{"location":"examples/office_tower/#model","title":"Model","text":"<p>The following diagram shows the key players of the model. The diagram was automatically created using Intellij's UML capabilities. </p> <p></p> <p>The simulation environment is modelled in <code>Elevator</code>. Multiple <code>VisitorGenerator</code>s produce <code>Visitor</code>s at different rates.  Each visitor has a target <code>Floor</code>, which defines the button (up or down) she is pressing to request a car. <code>Car</code>s - i.e. the elevator cabins - are the workhorse of the model. They have a fixed capacity, a current occupancy, a current floor and a state for the door. The cars and the visitors have associated process definitions to drive the dynamics of the model.</p>"},{"location":"examples/office_tower/#process-animation","title":"Process Animation","text":"<p>The model was also animated (source) to illustrate the power of kalasim's animation API.</p>"},{"location":"examples/traffic/","title":"Traffic","text":"<p>The following example integrates three simulation entities</p> <ul> <li>A gas station with a limited number of pumps</li> <li>A traffic light that prevents cars from driving</li> <li>Multiple cars that need to pass the cross with the traffic light to reach a gas station. There each car needs to refill before it is reaching its end of live within the simulation context.</li> </ul> <p>The example illustrates how to establish a simple interplay of  states and resources. It is realized elegantly with dependency injection.</p> <pre><code>////Traffic.kts\nimport org.kalasim.*\nimport org.koin.core.component.inject\n\nenum class TrafficLightState { RED, GREEN }\n\n/** A traffic light with 2 states. */\nclass TrafficLight : State&lt;TrafficLightState&gt;(TrafficLightState.RED) {\n\n    fun toggleState() {\n        when(value) {\n            TrafficLightState.RED -&gt; TrafficLightState.GREEN\n            TrafficLightState.GREEN -&gt; TrafficLightState.RED\n        }\n    }\n}\n\n\n/** A simple controller that will toggle the state of the traffic-light */\nclass TrafficLightController(val trafficLight: TrafficLight) : Component() {\n\n    override fun repeatedProcess() = sequence {\n        hold(6)\n        trafficLight.toggleState()\n    }\n}\n\n/** A gas station, where cars will stop for refill. */\nclass GasStation(numPumps: Int = 6) : Resource(capacity = numPumps)\n\n/** A car with a process definition detailing out its way to the gas-station via a crossing. */\nclass Car(val trafficLight: TrafficLight) : Component() {\n\n    val gasStation by inject&lt;GasStation&gt;()\n\n    override fun process() = sequence {\n        // Wait until the traffic light is green\n        wait(trafficLight, TrafficLightState.GREEN)\n\n        // Request a slot in the gas-station\n        request(gasStation) {\n            hold(5, description = \"refilling\")\n        }\n    }\n}\n\ncreateSimulation {\n    enableComponentLogger()\n\n    // Add a traffic light so that we can refer to it via koin get&lt;T&gt;()\n    dependency { TrafficLight() }\n\n    // Also add a resource with a limited capacity\n    dependency { GasStation(2) }\n\n    // Setup a traffic light controller to toggle the light\n    TrafficLightController(get())\n\n    // Setup a car generator with an exponentially distributed arrival time\n    ComponentGenerator(exponential(7).minutes) { Car(get()) }\n\n    // enable component tracking for later analytics\n    val cg = componentCollector()\n\n    // Run for 30 ticks\n    run(10)\n\n    // Toggle the traffic light manually\n    get&lt;TrafficLight&gt;().value = TrafficLightState.GREEN\n\n    // Run for another 10 ticks\n    run(10)\n\n    // Assess the state of the simulation entities\n    cg.filterIsInstance&lt;Car&gt;().first().stateTimeline.printHistogram()\n    get&lt;GasStation&gt;().printStatistics()\n}\n</code></pre> <p>Here,  we use both lazy injection with <code>inject&lt;T&gt;()</code> and instance retrieval with <code>get&lt;T&gt;()</code>. For details see koin reference</p>"},{"location":"examples/shipyard/bom_example/","title":"Bom example","text":"<p>Hull Components:</p> <p>1.Steel Plates (Quantity: 20)</p> <p>2.Bulkheads (Quantity: 5)</p> <p>3.Frames (Quantity: 15)</p> <p>4.Keel (Quantity: 1)</p> <p>Engines:</p> <p>1.Main Engine (Quantity: 2)</p> <p>2.Auxiliary Engines (Quantity: 3)</p> <p>Electrical Systems:</p> <ul> <li>Generators:</li> </ul> <p>1.Diesel Generators (Quantity: 2)</p> <p>2.Emergency Generator (Quantity: 1)</p> <ul> <li>Cabling and Wiring:</li> </ul> <p>1.Electrical Cables (Quantity: 500 meters)</p> <p>2.Wiring Harnesses (Quantity: 50)</p> <ul> <li>Switchgear:</li> </ul> <p>1.Circuit Breakers (Quantity: 30)</p> <p>2.Switch Panels (Quantity: 10)</p> <p>Navigation Equipment:</p> <p>1.Radar Systems (Quantity: 2)</p> <p>2.GPS Navigation Units (Quantity: 1)</p> <p>3.Compass (Quantity: 1)</p> <p>Safety Equipment:</p> <p>1.Lifeboats (Quantity: 4)</p> <p>2.Life Jackets (Quantity: 50)</p> <p>3.Fire Extinguishers (Quantity: 10)</p> <p>Interior Fixtures:</p> <p>1.Cabin Furniture (Quantity: 10 sets)</p> <p>2.Galley Equipment (Quantity: 1 set)</p> <p>Deck Machinery:</p> <p>1.Cranes (Quantity: 2)</p> <p>2.Winches (Quantity: 4)</p> <p>Miscellaneous:</p> <p>1.Paint (Quantity: 50 gallons)</p> <p>2.Nuts, Bolts, and Fasteners (Quantity: Assorted)</p>"},{"location":"examples/shipyard/shipyard/","title":"Bill of Materials (BOM) in Ship Final Assembly: A Key Component of Efficient Production","text":""},{"location":"examples/shipyard/shipyard/#introduction","title":"Introduction","text":"<p>The production process of complex structures such as ships involves meticulous planning, precision, and coordination of various components and materials. A crucial tool in this process is the Bill of Materials (BOM), which serves as a comprehensive document that outlines the list of components, materials, and parts required for the final assembly of a ship. In this article, we will explore how BOMs are used in ship final assembly, highlighting their importance in ensuring a smooth and efficient production process.</p>"},{"location":"examples/shipyard/shipyard/#what-is-a-bill-of-materials-bom","title":"What is a Bill of Materials (BOM)?","text":"<p>A Bill of Materials (BOM) is a structured list of all the items, components, and materials necessary to manufacture a product or assemble a final product, like a ship. It details each part's name, quantity, specifications, and the relationship between them. BOMs are crucial for coordinating various aspects of production, from sourcing materials to managing inventory and tracking costs.</p>"},{"location":"examples/shipyard/shipyard/#the-role-of-boms-in-ship-final-assembly","title":"The Role of BOMs in Ship Final Assembly","text":"<p>Inventory Management: BOMs help shipbuilders keep track of all the components needed for assembly. This allows for efficient inventory management, ensuring that the right materials are available when needed, minimizing delays in production.</p> <p>Quality Assurance: BOMs also include specifications and quality requirements for each component. This ensures that only the approved parts are used, reducing the likelihood of defects or safety issues in the final product.</p> <p>Cost Estimation: By providing a detailed list of materials and components, BOMs are invaluable in cost estimation and budgeting. They allow shipbuilders to calculate the overall production costs accurately, ensuring that the project remains within budget.</p> <p>Sourcing and Procurement: BOMs are used to create purchase orders for required materials and components. This helps streamline the procurement process, ensuring that the right parts are ordered in the correct quantities and from approved suppliers.</p> <p>Assembly Planning: BOMs serve as a roadmap for the assembly process. They help in organizing the assembly line and ensuring that workers have access to the necessary components in the right order, reducing assembly time and improving efficiency.</p>"},{"location":"examples/shipyard/shipyard/#example-ship-final-assembly","title":"Example: Ship Final Assembly","text":"<p>Let's consider the assembly of a cargo ship as an example. The ship's BOM would include a detailed list of all components, such as the hull, engines, electrical systems, navigation equipment, and more. Each of these components would have its own sub-BOMs, breaking down further into individual parts. For instance, the electrical system's sub-BOM might include cables, switches, and circuit boards, specifying the quantity, specifications, and suppliers for each.</p> <p>By having a well-structured BOM for the cargo ship, the shipbuilder can ensure that all components are available on time, that quality standards are met, and that the assembly process is efficient. This not only reduces the production timeline but also increases the overall quality and safety of the final product.</p> <p>How would a typical BOM in cargo ship final assembly look like</p>"},{"location":"examples/shipyard/shipyard/#conclusion","title":"Conclusion","text":"<p>Bill of Materials (BOMs) are an essential tool in the production process, especially in the complex field of ship assembly. They provide a detailed and organized overview of the materials and components required for final assembly, allowing for efficient management of inventory, quality assurance, cost estimation, and assembly planning. In shipbuilding, BOMs play a crucial role in ensuring that the final product is not only completed on time but also meets the highest quality and safety standards.</p>"}]}